<html><head/><body>



<title>Chapter 10. Neural Networks</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="ch10"/>第十章。神经网络</h1></div></div></div><p>在本章中，我们将介绍以下配方:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">建模标准普尔 500</li><li class="listitem" style="list-style-type: disc">衡量失业率</li></ul></div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec49"/>简介</h1></div></div></div><p><strong>神经网络</strong>:神经网络是一个有序的三元组<img src="img/image_10_001.jpg" alt="Introduction"/>，其中<img src="img/image_10_002.jpg" alt="Introduction"/>是一个神经元的集合，<img src="img/image_10_003.jpg" alt="Introduction"/>是一个集合<img src="img/image_10_004.jpg" alt="Introduction"/>，其元素称为神经元<img src="img/image_10_005.jpg" alt="Introduction"/>和神经元<img src="img/image_10_006.jpg" alt="Introduction"/>之间的连接，函数<img src="img/image_10_007.jpg" alt="Introduction"/>定义了权重，其中<img src="img/image_10_008.jpg" alt="Introduction"/>是神经元<img src="img/image_10_009.jpg" alt="Introduction"/>和神经元<img src="img/image_10_010.jpg" alt="Introduction"/>之间的连接的权重。数据通过连接在神经元之间传递，连接权重要么是兴奋性的，要么是抑制性的。</p></div></div>





<title>Modelling SP 500</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="ch10lvl1sec50"/>造型 SP 500</h1></div></div></div><p>在纽约证券交易所或纳斯达克综合指数上市的市值最大的 500 家公司的股票价值用标准普尔 500 来衡量。标准普尔以股票价格为基础，提供股票市场和经济运动的快速观察。标准普尔 500 指数是金融媒体和专业人士最常用的指标。标准普尔 500 指数的计算方法是将所有标准普尔 500 股票的调整后市值总和除以标准普尔开发的指数除数。当有可能影响指数价值的股票分割、特别股息或分拆时，会调整除数。除数确保这些非经济因素不会影响指数。</p><div><div><div><div><h2 class="title">准备就绪</h2></div></div></div><p>为了使用神经网络对标准普尔 500 指数建模，我们将使用从<code class="literal">GSPC</code>数据集收集的数据集。</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec156"/>步骤 1 -收集和描述数据</h3></div></div></div><p>要使用的数据集是 2009 年 1 月 1 日到 2014 年 1 月 1 日之间的<code class="literal">GSPC</code>每日收盘股票值。这个数据集可以在 https://www.yahoo.com/的<a class="ulink" href="https://www.yahoo.com/">上免费获得，我们将从那里下载数据。</a></p></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec63"/>怎么做...</h2></div></div></div><p>让我们进入细节。</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec157"/>第 2 步-探索数据</h3></div></div></div><p>首先，需要加载以下包:</p><pre class="programlisting">
<strong>    &gt; install.packages("quantmod")</strong>
<strong>    &gt; install.packages("neuralnet")</strong>
<strong>    &gt; library(quantmod)</strong>
<strong>    &gt; library(neuralnet)</strong>
</pre><p>让我们下载数据。我们将从标记所需时间段的开始和结束日期开始。</p><p><code class="literal">as.Date()</code>函数用于转换代表日历日期的<code class="literal">Date</code>类的字符表示和对象。</p><p>数据集的开始日期存储在<code class="literal">startDate</code>中，它代表日历日期的字符向量表示。这种表示的格式是 YYYY-MM-DD:</p><pre class="programlisting">
<strong>&gt; startDate = as.Date("2009-01-01")</strong>
</pre><p>数据集的结束日期存储在<code class="literal">endDate</code>中，它代表日历日期的字符向量表示。这种表示的格式是 YYYY-MM-DD:</p><pre class="programlisting">
<strong>&gt; endDate = as.Date("2014-01-01")</strong>
</pre><p>使用<code class="literal">getSymbols()</code>函数加载数据:该函数从本地或远程的多个数据源加载数据。<code class="literal">GSPC</code>是指定要加载的符号名称的字符向量。<code class="literal">src = yahoo</code>指定采购方式:</p><pre class="programlisting">
<strong>&gt; getSymbols("^GSPC", src="img/yahoo", from=startDate, to=endDate)</strong>
</pre><p>
</p><div><img src="img/image_10_011.jpg" alt="Step 2 - exploring data"/></div><p>
</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec158"/>步骤 3 -计算指标</h3></div></div></div><p>计算相对强弱指数:这是最近价格上升趋势和绝对价格变动之间的比率。<code class="literal">RSI()</code>函数用于计算<strong>相对强度指数</strong>。<code class="literal">GSPC</code>数据框用作价格系列。<code class="literal">n = 3</code>代表移动平均线的周期数。然后将结果存储在<code class="literal">relativeStrengthIndex3</code>数据帧中:</p><pre class="programlisting">
<strong>&gt; relativeStrengthIndex3 &lt;- RSI(Op(GSPC),n=3)</strong>
</pre><p>探索价格变化的摘要:<code class="literal">summary()</code>函数用于此。该函数提供一系列描述性统计数据，以生成<code class="literal">relativeStrengthIndex3</code>数据帧的结果汇总:</p><pre class="programlisting">
<strong>&gt; summary(relativeStrengthIndex3)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_10_012.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p><p><code class="literal">EMA()</code>函数使用<code class="literal">GSPC</code>符号作为价格序列。<code class="literal">n = 5</code>表示要平均的时间段。然后将结果存储在<code class="literal">exponentialMovingAverage5</code>数据帧中:</p><pre class="programlisting">
<strong>&gt; exponentialMovingAverage5 &lt;- EMA(Op(GSPC),n=5)</strong>
</pre><p>打印<code class="literal">exponentialMovingAverage5</code>数据帧:<code class="literal">head()</code>函数返回<code class="literal">exponentialMovingAverage5</code>数据帧的第一部分。<code class="literal">exponentialMovingAverage5</code>数据帧作为输入参数传递:</p><pre class="programlisting">
<strong>&gt; head(exponentialMovingAverage5)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_10_013.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p><p>探究价格变化的概要。为此，使用<code class="literal">summary()</code>功能。该功能提供一系列描述性统计数据，以生成<code class="literal">exponentialMovingAverage5</code>数据框的结果汇总。</p><pre class="programlisting">
<strong>&gt; summary(exponentialMovingAverage5)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_10_014.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p><p>计算<code class="literal">GSPC</code>和<code class="literal">exponentialMovingAverage5</code>的指数开盘价之差:</p><pre class="programlisting">
<strong>&gt; exponentialMovingAverageDiff &lt;- Op(GSPC) - exponentialMovingAverage5</strong>
</pre><p>现在让我们打印<code class="literal">exponentialMovingAverageDiff</code>数据帧。<code class="literal">head()</code>函数返回<code class="literal">exponentialMovingAverageDiff</code>数据帧的第一部分。<code class="literal">exponentialMovingAverageDiff</code>数据帧作为输入参数传递:</p><pre class="programlisting">
<strong>&gt; head(exponentialMovingAverageDiff)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_10_015.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p><p>探索价格变化的汇总:为此，使用了<code class="literal">summary()</code>函数。该功能提供一系列描述性统计数据，以生成<code class="literal">exponentialMovingAverageDiff</code>数据帧的结果汇总。</p><pre class="programlisting">
<strong>&gt; summary(exponentialMovingAverageDiff)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_10_016.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p><p>我们现在将比较<code class="literal">GSPC</code>系列的快速移动平均线和<code class="literal">GSPC</code>系列的慢速移动平均线。为此，<code class="literal">GSPC</code>被作为价格矩阵传递。<code class="literal">fast = 12</code>代表快速移动平均线的周期，<code class="literal">slow = 26</code>代表慢速移动平均线的周期，<code class="literal">signal = 9</code>代表移动平均线的信号:</p><pre class="programlisting">
<strong>&gt; MACD &lt;- MACD(Op(GSPC),fast = 12, slow = 26, signal = 9)</strong>
</pre><p>打印<code class="literal">MACD</code>数据帧:<code class="literal">tail()</code>函数返回<code class="literal">MACD</code>数据帧的最后一部分。<code class="literal">MACD</code>数据帧作为输入参数传递:</p><pre class="programlisting">
<strong>&gt; tail(MACD)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_10_017.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p><p>使用<code class="literal">summary()</code>功能浏览价格变化汇总:</p><pre class="programlisting">
<strong>&gt; summary(MACD)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_10_018.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p><p>接下来，我们将抓住信号线作为一个指标。结果存储在<code class="literal">MACDsignal</code>数据帧中:</p><pre class="programlisting">
<strong>&gt; MACDsignal &lt;- MACD[,2]</strong>
</pre><p>计算<strong>布林线</strong>:它们是区间指标，计算均线的标准差。布林线运行的逻辑是，货币对的价格最有可能向其平均值靠拢；因此，当它偏离得太远时，比如说偏离两个标准差，它就会回落到均线。<code class="literal">BBands()</code>函数用于计算布林线。<code class="literal">GSPC</code>作为对象传递，<code class="literal">n=20</code>表示移动平均线的周期数。<code class="literal">sd=2</code>表示两个标准差:</p><pre class="programlisting">
<strong>&gt; BollingerBands &lt;- BBands(Op(GSPC),n=20,sd=2)</strong>
</pre><p>现在让我们打印<code class="literal">BollingerBands</code>数据帧:</p><pre class="programlisting">
<strong>&gt; tail(BollingerBands)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_10_019.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p><p>探索价格变化的摘要:</p><pre class="programlisting">
<strong>&gt; summary(BollingerBands)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_10_020.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p><p>现在让我们抓住<code class="literal">BollingerBands</code>的信号线作为指示器:</p><pre class="programlisting">
<strong>&gt; PercentageChngpctB &lt;- BollingerBands[,4]</strong>
</pre><p>打印<code class="literal">PercentageChngpctB</code>数据帧:</p><pre class="programlisting">
<strong>&gt; tail(PercentageChngpctB)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_10_021.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p><p>在<code class="literal">PercentageChngpctB</code>中探索这一变化的总结:</p><pre class="programlisting">
<strong>&gt; summary(PercentageChngpctB)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_10_022.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p><p>找出收盘价和开盘价之间的差异:</p><pre class="programlisting">
<strong>&gt; Price &lt;- Cl(GSPC)-Op(GSPC)</strong>
</pre><p>打印<code class="literal">price</code>数据帧:</p><pre class="programlisting">
<strong>&gt; tail(Price)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_10_023.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p><p>组合<code class="literal">relativeStrengthIndex3</code>、<code class="literal">expMvAvg5Cross</code>、<code class="literal">MACDsignal</code>和<code class="literal">PercentageChngpctB</code>、<code class="literal">Price</code>数据帧；结果存储在<code class="literal">DataSet</code>数据帧中；</p><pre class="programlisting">
<strong>&gt; DataSet &lt;- data.frame(relativeStrengthIndex3, expMvAvg5Cross, MACDsignal, PercentageChngpctB, Price)</strong>
</pre><p>探索<code class="literal">DataSet</code>数据帧的内部结构:<code class="literal">str()</code>函数显示数据帧的内部结构。<code class="literal">DataSet</code>作为 R 对象传递给<code class="literal">str()</code>函数:</p><pre class="programlisting">
<strong>&gt; str(DataSet)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_10_024.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p><p>计算指标、创建数据集和移除点:</p><pre class="programlisting">
<strong>&gt; DataSet &lt;- DataSet[-c(1:33),]</strong>
</pre><p>探索<code class="literal">DataSet</code>数据帧的尺寸:<code class="literal">dim()</code>函数返回<code class="literal">DataSet</code>帧的尺寸。<code class="literal">DataSet</code>数据帧作为输入参数传递。结果清楚地表明有 1，176 行数据和 5 列:</p><pre class="programlisting">
<strong>&gt; dim(DataSet)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_10_025.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p><p>命名列:<code class="literal">c()</code>函数用于将参数组合成向量；</p><pre class="programlisting">
<strong>&gt; colnames(DataSet) &lt;- c("RSI3","EMAcross","MACDsignal","BollingerB","Price")</strong>
</pre><p>探索<code class="literal">DataSet</code>数据框的尺寸:</p><pre class="programlisting">
<strong>&gt; str(DataSet)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_10_026.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec159"/>步骤 4 -为模型构建准备数据</h3></div></div></div><p>将数据集规范化为绑定在 0 和 1 之间:</p><pre class="programlisting">
<strong>&gt; Normalized &lt;- function(x) {(x-min(x))/(max(x)-min(x))}</strong>
</pre><p>调用函数来规范化数据集:</p><pre class="programlisting">
<strong>&gt; NormalizedData &lt;- as.data.frame(lapply(DataSet,Normalized))</strong>
</pre><p>打印<code class="literal">NormalizedData</code>数据帧:</p><pre class="programlisting">
<strong>&gt; tail(NormalizedData)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_10_027.jpg" alt="Step 4 - preparing data for model building"/></div><p>
</p><p>建立训练数据集:来自<code class="literal">NormalizedData</code>数据框中<code class="literal">1:816</code>的数据元素将被用作训练数据集。训练数据集应存储在<code class="literal">TrainingSet</code>中:</p><pre class="programlisting">
<strong>&gt; TrainingSet &lt;- NormalizedData[1:816,]</strong>
</pre><p>探索<code class="literal">TrainingSet</code>数据框的维度:</p><pre class="programlisting">
<strong>&gt; dim(TrainingSet)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_10_028.jpg" alt="Step 4 - preparing data for model building"/></div><p>
</p><p>探索<code class="literal">TrainingSet</code>中的变化总结:</p><pre class="programlisting">
<strong>&gt; summary(TrainingSet)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_10_029.jpg" alt="Step 4 - preparing data for model building"/></div><p>
</p><p>构建测试数据集:来自<code class="literal">NormalizedData</code>数据框中<code class="literal">817:1225</code>的数据元素将被用作训练数据集。该测试数据集应存储在<code class="literal">TestSet</code>中:</p><pre class="programlisting">
<strong>&gt; TestSet &lt;- NormalizedData[817:1225 ,]</strong>
</pre><p>探索<code class="literal">TrainingSet</code>数据框的尺寸:</p><pre class="programlisting">
<strong>&gt; dim(TestSet)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_10_030.jpg" alt="Step 4 - preparing data for model building"/></div><p>
</p><p>探索<code class="literal">TestSet</code>中的变化总结:</p><pre class="programlisting">
<strong>&gt; summary(TestSet)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_10_031.jpg" alt="Step 4 - preparing data for model building"/></div><p>
</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec160"/>第五步-建立模型</h3></div></div></div><p>构建神经网络:<code class="literal">neuralnet()</code>函数使用没有权重回溯的反向传播算法训练神经网络。<code class="literal">Price~RSI3+EMAcross+MACDsignal+BollingerB</code>是待拟合模型的描述。<code class="literal">data=TrainingSet</code>是包含公式中指定变量的数据框。<code class="literal">hidden=c(3,3)</code>指定每层中隐藏神经元(顶点)的数量。<code class="literal">learningrate=.001</code>表示反向传播算法使用的学习率。<code class="literal">algorithm="backprop"</code>指反向传播算法:</p><pre class="programlisting">
<strong>&gt; nn1 &lt;- neuralnet(Price~RSI3+EMAcross+MACDsignal+BollingerB,data=TrainingSet, hidden=c(3,3), learningrate=.001,algorithm="backprop")</strong>
</pre><p>绘制神经网络:</p><pre class="programlisting">
<strong>&gt; plot(nn1)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_10_032.jpg" alt="Step 5 - building the model"/></div><p>
</p></div></div></div>





<title>Measuring the unemployment rate</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="ch10lvl1sec51"/>测量失业率</h1></div></div></div><p>失业率被定义为失业但积极寻找工作并愿意工作的总劳动力的百分比。根据国际劳工组织的定义，失业者是指那些积极寻找工作却没有工作的人。失业率是对既失业又在找工作的人数的衡量。</p><div><div><div><div><h2 class="title">做好准备</h2></div></div></div><p>为了使用神经网络对失业率进行测量，我们将使用在威斯康星州收集的失业率数据集。</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec161"/>步骤 1 -收集和描述数据</h3></div></div></div><p>为此，我们将使用名为<code class="literal">FRED-WIUR.csv</code>的 CSV 数据集。有 448 行数据。有如下两个数值变量:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Date</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Value</code></li></ul></div><p>该数据集显示了 1976 年 1 月 1 日至 2013 年 4 月 1 日期间威斯康星州的失业率。</p></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec65"/>怎么做...</h2></div></div></div><p>让我们进入细节。</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec162"/>步骤 2 -探索数据</h3></div></div></div><p>首先，需要加载以下包:</p><pre class="programlisting">
<strong>    &gt; install.packages("forecast ")</strong>
<strong>    &gt; install.packages("lmtest") </strong>
<strong>    &gt; install.packages("caret ")</strong>
<strong>    &gt; library(forecast)</strong>
<strong>    &gt; library(lmtest)</strong>
<strong>    &gt; library(caret)</strong>
</pre><div><div><h3 class="title"><a id="note29"/>注</h3><p>版本信息:这个页面的代码在 R 版本 3.3.0 中测试过</p></div></div><p>让我们探索数据，了解变量之间的关系。我们将从导入名为<code class="literal">FRED-WIUR.csv</code>的 CSV 数据文件开始。我们将把数据保存到<code class="literal">ud</code>数据框中:</p><pre class="programlisting">
<strong>&gt; ud &lt;- read.csv("d:/FRED-WIUR.csv", colClasses=c('Date'='Date'))</strong>
</pre><p>打印<code class="literal">ud</code>数据帧:<code class="literal">tail()</code>函数返回<code class="literal">ud</code>数据帧的最后一部分。<code class="literal">ud</code>数据帧作为输入参数传递:</p><pre class="programlisting">
<strong>&gt; tail(ud)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_10_033.jpg" alt="Step 2 - exploring data"/></div><p>
</p><p>命名列:<code class="literal">c()</code>函数用于将参数组合成向量；</p><pre class="programlisting">
<strong>&gt; colnames(ud) &lt;- c('date', 'rate')</strong>
</pre><p><code class="literal">as.Date()</code>函数用于转换代表日历日期的<code class="literal">Date</code>类的字符表示和对象:</p><pre class="programlisting">
<strong>&gt; ud$date &lt;- as.Date(ud$date)</strong>
</pre><p>探索失业数据的汇总:为此，使用了<code class="literal">summary()</code>函数。该函数提供了一系列描述性统计数据，以生成<code class="literal">ud</code>数据帧的结果汇总:</p><pre class="programlisting">
<strong>&gt; summary (ud)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_10_034.jpg" alt="Step 2 - exploring data"/></div><p>
</p><p>现在让我们从第 1 行到第 436 行创建基本数据:</p><pre class="programlisting">
<strong>&gt; ud.b &lt;- ud[1:436,]</strong>
</pre><p>探索基本失业数据的汇总。为此，使用了<code class="literal">summary()</code>功能。该函数提供了一系列描述性统计数据，以生成<code class="literal">ud.b</code>数据帧的结果汇总:</p><pre class="programlisting">
<strong>&gt; summary(ud.b)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_10_035.jpg" alt="Step 2 - exploring data"/></div><p>
</p><p>现在让我们从第 437 行到第 448 行创建测试数据:</p><pre class="programlisting">
<strong>&gt; ud.p &lt;- ud[437:448,]</strong>
</pre><p>探索测试失业数据的摘要:</p><pre class="programlisting">
<strong>&gt; summary(ud.p)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_10_036.jpg" alt="Step 2 - exploring data"/></div><p>
</p><p>创建 1976 年以来的基本时间序列数据:<code class="literal">ts()</code>作为一个函数创建时间序列对象。<code class="literal">ud.b$rate</code>代表观测时间序列值的向量:</p><pre class="programlisting">
<strong>&gt; ud.ts &lt;- ts(ud.b$rate, start=c(1976, 1), frequency=12)</strong>
</pre><p>打印<code class="literal">ud.ts</code>数据帧的值:</p><pre class="programlisting">
<strong>&gt; ud.ts</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_10_037.jpg" alt="Step 2 - exploring data"/></div><p>
</p><p>创建测试时间序列数据:<code class="literal">ts()</code>函数创建时间序列对象。<code class="literal">ud.b$rate</code>代表观测时间序列值的向量:</p><pre class="programlisting">
<strong>&gt; ud.p.ts &lt;- ts(ud.p$rate, start=c(2012, 5), frequency=12)</strong>
</pre><p>打印<code class="literal">ud.ts</code>数据帧的值:</p><pre class="programlisting">
<strong>&gt; ud.ts</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_10_038.jpg" alt="Step 2 - exploring data"/></div><p>
</p><p>绘制基本时间序列数据:</p><pre class="programlisting">
<strong>&gt; plot.ts(ud.ts)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_10_039.jpg" alt="Step 2 - exploring data"/></div><p>
</p><p>绘制测试时间序列数据:</p><pre class="programlisting">
<strong>&gt; plot.ts(ud.p.ts)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_10_040.jpg" alt="Step 2 - exploring data"/></div><p>
</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec163"/>步骤 3 -准备和验证模型</h3></div></div></div><p>计算基本时间序列数据集的平均值。<code class="literal">meanf()</code>函数返回应用于<code class="literal">ud.ts</code>数据集的<strong> i.i.d </strong>模型的预测和预测区间。<code class="literal">12</code>表示预测的期间:</p><pre class="programlisting">
<strong>&gt; mean &lt;- meanf(ud.ts, 12)</strong>
</pre><p>用漂移基时间序列预测随机行走的时间间隔。<code class="literal">rwf()</code>函数预测并返回对时间序列<code class="literal">ud.ts</code>执行的随机行走。参数<code class="literal">12</code>表示预测的周期:</p><pre class="programlisting">
<strong>&gt; forecast_randomwalk &lt;- rwf(ud.ts, 12)</strong>
</pre><p>从 ARIMA(0，0，0)(0，1，0)m 基本时间序列预测和预测随机行走的间隔:<code class="literal">snaive()</code>函数预测并返回对时间序列<code class="literal">ud.ts</code>执行的 ARIMA(0，0，0)(0，1，0)m 的结果。参数<code class="literal">12</code>表示预测的周期:</p><pre class="programlisting">
<strong>&gt; forecast_arima &lt;- snaive(ud.ts, 12)</strong>
</pre><p>预测和预测基本时间序列的漂移。<code class="literal">rwf()</code>函数预测并返回对时间序列<code class="literal">ud.ts</code>执行的随机行走。参数<code class="literal">12</code>表示预测的周期。<code class="literal">drift=T</code>是符合漂移模型的随机游走的逻辑标志:</p><pre class="programlisting">
<strong>&gt; drift &lt;- rwf(ud.ts, 12, drift=T)</strong>
</pre><p>接下来，我们将为趋势的基本时间序列数据准备线性拟合模型。<code class="literal">tslm()</code>函数将线性模型拟合到<code class="literal">ud.ts</code>时间序列。<code class="literal">ud.ts~trend</code>是表示必须考虑趋势成分的公式:</p><pre class="programlisting">
<strong>&gt; m1 &lt;- tslm(ud.ts~trend)</strong>
</pre><p>为趋势和季节性的基本时间序列数据准备线性拟合模型:<code class="literal">tslm()</code>函数将线性模型拟合到<code class="literal">ud.ts</code>时间序列。<code class="literal">ud.ts~trend+season</code>是表示必须考虑趋势和季节性因素的公式:</p><pre class="programlisting">
<strong>&gt; m2 &lt;- tslm(ud.ts~trend+season)</strong>
</pre><p><code class="literal">residuals()</code>是一个通用函数，在拟合基本时间序列数据的趋势模型后，从返回的对象<code class="literal">m1</code>中提取模型残差。</p><pre class="programlisting">
<strong>&gt; residual_1 &lt;- residuals(m1)</strong>
</pre><p>绘制残差模型:</p><pre class="programlisting">
<strong>&gt; plot(residual_1, ylab="Residuals",xlab="Year", title("Residual - Trends"), col = "red")</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_10_041.jpg" alt="Step 3 - preparing and verifying the models"/></div><p>
</p><p>现在我们来看看如何估计<code class="literal">autocovariance</code>函数。<code class="literal">residual_1</code>是一元数值时间序列对象:</p><pre class="programlisting">
<strong>&gt; acf(residual_1, main="ACF of residuals")</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_10_042.jpg" alt="Step 3 - preparing and verifying the models"/></div><p>
</p><p><code class="literal">residuals()</code>是一个通用函数，在拟合基本时间序列数据的模型以获得趋势后，从返回的对象<code class="literal">m2</code>中提取模型残差。</p><pre class="programlisting">
<strong>&gt; residual_2 &lt;- residuals(m2)</strong>
</pre><p>绘制剩余模型:</p><pre class="programlisting">
<strong>&gt; plot(residual_2, ylab="Residuals",xlab="Year",title("Residual - Trends + Seasonality"), col = "red")</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_10_043.jpg" alt="Step 3 - preparing and verifying the models"/></div><p>
</p><pre class="programlisting">
<strong>&gt; acf(residual_2, main="ACF of residuals")</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_10_044.jpg" alt="Step 3 - preparing and verifying the models"/></div><p>
</p><p>Durbin-Watson 检验用于确定线性回归或多重回归的残差是否独立。杜宾-沃森检验中通常考虑的假设如下:</p><p>
</p><div><img src="img/image_10_045.jpg" alt="Step 3 - preparing and verifying the models"/></div><p>
</p><p>
</p><div><img src="img/image_10_046.jpg" alt="Step 3 - preparing and verifying the models"/></div><p>
</p><p>测试统计数据如下所示:</p><p>
</p><div><img src="img/image_10_047.jpg" alt="Step 3 - preparing and verifying the models"/></div><p>
</p><p>在这个方程中，<img src="img/image_10_048.jpg" alt="Step 3 - preparing and verifying the models"/>、<img src="img/image_10_049.jpg" alt="Step 3 - preparing and verifying the models"/>是个体<img src="img/image_10_050.jpg" alt="Step 3 - preparing and verifying the models"/>的观测值，<img src="img/image_10_051.jpg" alt="Step 3 - preparing and verifying the models"/>是个体<img src="img/image_10_052.jpg" alt="Step 3 - preparing and verifying the models"/>的预测值。</p><p><img src="img/image_10_053.jpg" alt="Step 3 - preparing and verifying the models"/>的值随着串行相关性的增加而减小。针对<img src="img/image_10_056.jpg" alt="Step 3 - preparing and verifying the models"/> -解释变量数量和<img src="img/image_10_057.jpg" alt="Step 3 - preparing and verifying the models"/>的不同值，列出了上下临界值<img src="img/image_10_054.jpg" alt="Step 3 - preparing and verifying the models"/>和<img src="img/image_10_055.jpg" alt="Step 3 - preparing and verifying the models"/>:</p><p>如果<img src="img/image_10_058.jpg" alt="Step 3 - preparing and verifying the models"/>拒绝<img src="img/image_10_059.jpg" alt="Step 3 - preparing and verifying the models"/></p><p>如果<img src="img/image_10_060.jpg" alt="Step 3 - preparing and verifying the models"/>不拒绝<img src="img/image_10_061.jpg" alt="Step 3 - preparing and verifying the models"/></p><p>如果测试没有结果。</p><p>对趋势的基本时间序列数据的线性拟合模型执行 Durbin-Watson 测试:</p><pre class="programlisting">
<strong>&gt; dwtest(m1, alt="two.sided")</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_10_063.jpg" alt="Step 3 - preparing and verifying the models"/></div><p>
</p><p>对趋势和季节性的基本时间序列数据的线性拟合模型执行 Durbin-Watson 测试:</p><pre class="programlisting">
<strong>    &gt; dwtest(m2, alt="two.sided")</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_10_064.jpg" alt="Step 3 - preparing and verifying the models"/></div><p>
</p><p>使用黄土将基本数据时间序列分解为周期、季节、趋势和不规则成分:</p><pre class="programlisting">
<strong>&gt; m3 &lt;- stl(ud.ts, s.window='periodic')</strong>
</pre><p>绘制分解的基础数据时间序列:</p><pre class="programlisting">
<strong>&gt; plot(m3)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_10_065.jpg" alt="Step 3 - preparing and verifying the models"/></div><p>
</p><p>对基本数据时间序列执行指数平滑状态空间模型。<code class="literal">ets()</code>函数返回<code class="literal">ud.ts</code>时间序列的<code class="literal">ets</code>模型。<code class="literal">ZZZ - "Z"</code>表示自动选择。第一个字母表示错误类型，第二个字母表示趋势类型，第三个字母表示季节类型:</p><pre class="programlisting">
<strong>&gt; m4 &lt;- ets(ud.ts, model='ZZZ')</strong>
</pre><p>绘制基本数据时间序列的指数平滑状态空间模型:</p><pre class="programlisting">
<strong>&gt; plot(m4)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_10_066.jpg" alt="Step 3 - preparing and verifying the models"/></div><p>
</p><p>返回基本数据时间序列的单变量 ARIMA 的顺序:</p><pre class="programlisting">
<strong>&gt; m5 &lt;- auto.arima(ud.ts)</strong>
</pre><p>绘制基础数据时间序列的单变量 ARIMA:</p><pre class="programlisting">
<strong>&gt; plot(forecast(m5, h=12))</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_10_067.jpg" alt="Step 3 - preparing and verifying the models"/></div><p>
</p><p>构建前馈神经网络模型:<code class="literal">nnetar()</code>函数构建单隐层、滞后输入的前馈神经网络，用于预测基础数据单变量时间序列；</p><pre class="programlisting">
<strong>&gt; m6 &lt;- nnetar(ud.ts)</strong>
</pre><p>打印前馈神经网络模型的值:</p><pre class="programlisting">
<strong>&gt; m6</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_10_068.jpg" alt="Step 3 - preparing and verifying the models"/></div><p>
</p><p>绘制前馈神经网络模型:</p><pre class="programlisting">
<strong>&gt; plot(forecast(m6, h=12))</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_10_069.jpg" alt="Step 3 - preparing and verifying the models"/></div><p>
</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec164"/>步骤 4 -预测和测试所建模型的准确性</h3></div></div></div><p>用测试数据时间序列检验基础数据时间序列平均值的准确性。<code class="literal">accuracy()</code>函数返回预测准确度的汇总测量范围。<code class="literal">ud.p.ts</code>是测试数据时间序列:</p><pre class="programlisting">
<strong>&gt; a1 &lt;- accuracy(mean, ud.p.ts)</strong>
</pre><p>测试预测的和预测的具有漂移的基础数据时间序列的准确性:</p><pre class="programlisting">
<strong>&gt; a2 &lt;- accuracy(forecast_randomwalk, ud.p.ts)</strong>
</pre><p>用 ARIMA(0，0，0)(0，1，0)m 检验预测的和预测的基础数据时间序列的精度:</p><pre class="programlisting">
<strong>&gt; a3 &lt;- accuracy(forecast_arima, ud.p.ts)</strong>
</pre><p>测试基本数据时间序列漂移的准确性:</p><pre class="programlisting">
<strong>&gt; a4 &lt;- accuracy(drift, ud.p.ts)</strong>
</pre><p>将结果合并到一个表格中:</p><pre class="programlisting">
<strong>&gt; a.table &lt;- rbind(a1, a2, a3, a4)</strong>
</pre><p>打印结果:</p><pre class="programlisting">
<strong>&gt; a.table</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_10_070.jpg" alt="Step 4 - forecasting and testing the accuracy of the models built"/></div><p>
</p><p>预测趋势基本时间序列数据的线性拟合模型。<code class="literal">h=12</code>表示预测的时间段:</p><pre class="programlisting">
<strong>&gt; f1 &lt;- forecast(m1, h=12)</strong>
</pre><p>预测趋势和季节性的基本时间序列数据的线性拟合模型:</p><pre class="programlisting">
<strong>&gt; f2 &lt;- forecast(m2, h=12)</strong>
</pre><p>使用黄土预测分解为周期、季节、趋势和不规则成分的基础数据时间序列:</p><pre class="programlisting">
<strong>&gt; f3 &lt;- forecast(m3, h=12)</strong>
</pre><p>预测基本数据时间序列的指数平滑状态空间模型:</p><pre class="programlisting">
<strong>&gt; f4 &lt;- forecast(m4, h=12)</strong>
</pre><p>预测基本数据时间序列的有序单变量 ARIMA:</p><pre class="programlisting">
<strong>&gt; f5 &lt;- forecast(m5, h=12)</strong>
</pre><p>单隐层前馈神经网络模型的预测；</p><pre class="programlisting">
<strong>&gt; f6 &lt;- forecast(m6, h=12)</strong>
</pre><p>测试趋势基本时间序列数据的预测线性拟合模型的准确性:</p><pre class="programlisting">
<strong>&gt; a5 &lt;- accuracy(f1, ud.p.ts)</strong>
</pre><p>测试趋势和季节性的基本时间序列数据的预测线性拟合模型的准确性:</p><pre class="programlisting">
<strong>&gt; a6 &lt;- accuracy(f2, ud.p.ts)</strong>
</pre><p>使用黄土测试将预测的基础数据时间序列分解为周期、季节、趋势和不规则成分的准确性:</p><pre class="programlisting">
<strong>&gt; a7 &lt;- accuracy(f3, ud.p.ts)</strong>
</pre><p>测试基本数据时间序列的预测指数平滑状态空间模型的准确性:</p><pre class="programlisting">
<strong>&gt; a8 &lt;- accuracy(f4, ud.p.ts)</strong>
</pre><p>测试基础数据时间序列的预测有序单变量 ARIMA 的准确性:</p><pre class="programlisting">
<strong>&gt; a9 &lt;- accuracy(f5, ud.p.ts)</strong>
</pre><p>测试具有单个隐藏层的预测前馈神经网络模型的准确性:</p><pre class="programlisting">
<strong>&gt; a10 &lt;- accuracy(f6, ud.p.ts)</strong>
</pre><p>将结果合并到一个表格中:</p><pre class="programlisting">
<strong>&gt; a.table.1 &lt;- rbind(a5, a6, a7, a8, a9, a10)</strong>
</pre><p>打印结果:</p><pre class="programlisting">
<strong>&gt; a.table.1</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_10_071.jpg" alt="Step 4 - forecasting and testing the accuracy of the models built"/></div><p>
</p></div></div></div>
</body></html>