<html><head/><body>



<title>Chapter 6. Supervised Learning</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="ch06"/>第六章。监督学习</h1></div></div></div><p>在本章中，我们将介绍以下配方:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">决策树学习——胸痛患者的高级健康指导</li><li class="listitem" style="list-style-type: disc">决策树学习-基于收入的房地产价值分布</li><li class="listitem" style="list-style-type: disc">决策树学习-预测股票运动的方向</li><li class="listitem" style="list-style-type: disc">朴素贝叶斯-预测股票运动的方向</li><li class="listitem" style="list-style-type: disc">随机森林货币交易策略</li><li class="listitem" style="list-style-type: disc">支持向量机-货币交易策略</li><li class="listitem" style="list-style-type: disc">随机梯度下降-成人收入</li></ul></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec29"/>简介</h1></div></div></div><p><strong>决策树学习</strong>:决策树是非常流行的分类和预测问题的工具。决策树是一个递归划分实例空间或变量集的分类器。决策树被表示为树结构，其中每个节点可以被分类为叶节点或决策节点。叶节点保存目标属性的值，而决策节点指定要在单个属性值上实现的规则。每个决策节点根据输入属性值的某个离散函数将实例空间分成两个或多个子空间。每个测试只考虑一个属性，因此实例空间根据属性值进行划分。在数值属性的情况下，条件是指一个范围。在决策节点上实现规则后，一个子树就是一个结果。每个叶节点保存概率向量，该概率向量指示目标属性具有某个值的概率。根据路径上的测试结果，通过将实例从树根向下导航到树叶来对实例进行分类。</p><p>使用决策树挖掘数据的关键要求如下:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>属性值描述</strong>:对象可以表示为一组固定的属性或特性</li><li class="listitem" style="list-style-type: disc"><strong>预定义类别</strong>:样本被分配到的类别必须是监督数据</li><li class="listitem" style="list-style-type: disc"><strong>充分数据</strong>:使用多个训练案例</li></ul></div><p><strong>朴素贝叶斯</strong> : <strong> </strong>朴素贝叶斯是一种监督学习方法。它是一个线性分类器。它基于贝叶斯定理，该定理指出一个类的特定特征的存在与任何其他特征的存在无关。这是一种稳健而有效的算法。贝叶斯分类器可以预测类成员概率，例如给定元组属于特定类的概率。贝叶斯信念网络是联合条件概率分布。它允许在变量子集之间定义类条件独立性。它提供了一个因果关系的图形模型，在此基础上可以进行学习。</p><p><strong>随机森林</strong>:随机森林是决策树的集合，提供对数据结构的预测。它们是一种工具，可以在明智的随机化和集成学习中发挥多决策树的力量，以产生预测模型。它们为每个记录提供可变排名、缺失值、分段和报告，以确保深入理解数据。在构建了每棵树之后，所有的数据都沿着树向下运行。对于每对案例，计算邻域。如果两个案例占据相同的终端节点，则它们的邻域增加1。在运行结束时，通过除以树的数量来进行归一化。邻近法用于替换缺失数据、定位异常值以及揭示数据的低维理解。训练数据是袋外数据，用于估计分类误差和计算变量的重要性。</p><p>随机森林在大型数据库上运行非常高效，产生准确的结果。它们在不删除的情况下处理多个变量，对变量的重要性进行估计，以解决分类问题。随着森林建设的进展，它们生成概化误差的内部无偏估计。随机森林是估计缺失数据的有效方法，并且在大部分数据缺失时保持准确性。</p><p><strong>支持向量机</strong>:机器学习算法使用正确的特征集来解决学习问题。支持向量机利用(非线性)映射函数φ，该函数将输入空间中的数据转换为特征空间中的数据，使得问题可以线性分离。然后，SVM发现最优分离超平面，然后通过φ-1将其映射回输入空间。在可能的超平面中，我们选择超平面离最近的数据点的距离(边缘)尽可能大的一个。</p></div></div>





<title>Decision tree learning - Advance Health Directive for patients with chest pain</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="ch06lvl1sec30"/>决策树学习——胸痛患者提前健康指导</h1></div></div></div><p>预先健康指示文件规定了关于个人在各种医疗条件下的未来健康护理的方向。它指导个人在紧急情况下或必要时做出正确的决定。该文件帮助个人理解其医疗保健决定的性质和后果，理解指令的性质和效果，自由和自愿地做出这些决定，并以某种方式传达这些决定。</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec32"/>做好准备</h2></div></div></div><p>为了执行决策树分类，我们将使用从心脏病患者数据集收集的数据集。</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec81"/>步骤1 -收集和描述数据</h3></div></div></div><p>将使用CSV格式的名为<code class="literal">Heart.csv</code>的数据集。数据集采用标准格式。有303行数据。有15个变量。数字变量如下:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Age</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Sex</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">RestBP</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Chol</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Fbs</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">RestECG</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">MaxHR</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ExAng</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Oldpeak</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Slope</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Ca</code></li></ul></div><p>非数字变量如下:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ChestPain</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Thal</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">AHD</code></li></ul></div></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec33"/>怎么做...</h2></div></div></div><p>让我们进入细节。</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec82"/>第2步-探索数据</h3></div></div></div><p>作为要执行的第一步，需要加载以下软件包:</p><pre class="programlisting">
<strong>&gt; install.packages("tree")
&gt; install.packages("caret")
&gt; install.packages("e1071")
&gt; library(tree)
&gt; library(caret)</strong>
</pre><div><div><h3 class="title"><a id="note13"/>注意</h3><p>版本信息:此页面的代码在R版本3.3.0中进行了测试(2016-05-03)。</p></div></div><p>让我们探索数据，了解变量之间的关系。我们将从导入名为<code class="literal">Heart.csv</code>的CSV数据文件开始。我们将把数据保存到<code class="literal">AHD_data</code>数据框:</p><pre class="programlisting">
<strong>    &gt; AHD_data &lt;- read.csv("d:/Heart.csv", header = TRUE)</strong>
</pre><p>探索<code class="literal">AHD_data</code>数据帧的内部结构。<code class="literal">str()</code>功能显示数据帧的内部结构。<code class="literal">AHD_data</code>作为R对象传递给<code class="literal">str()</code>函数:</p><pre class="programlisting">
<strong>    &gt; str(AHD_data) </strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_06_001.jpg" alt="Step 2 - exploring the data"/></div><p>
</p><p>打印<code class="literal">AHD_data</code>数据框。<code class="literal">head()</code>函数返回<code class="literal">AHD_data</code>数据帧的第一部分。<code class="literal">AHD_data</code>数据帧作为输入参数传递:</p><pre class="programlisting">
<strong>    &gt; head(AHD_data)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_06_002.jpg" alt="Step 2 - exploring the data"/></div><p>
</p><p>探索<code class="literal">AHD_data</code>数据框的尺寸。<code class="literal">dim()</code>函数返回<code class="literal">AHD_data</code>框架的尺寸。<code class="literal">AHD_data</code>数据帧作为输入参数传递。结果清楚地表明有303行数据和15列:</p><pre class="programlisting">
<strong>    &gt;dim(AHD_data)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_06_003.jpg" alt="Step 2 - exploring the data"/></div><p>
</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec83"/>步骤3 -准备数据</h3></div></div></div><p>需要为执行模型建立和测试准备数据。数据分为两部分——一部分用于构建模型，另一部分用于测试将要准备的模型。</p><p><code class="literal">createDataPartition()</code>函数用于创建数据分割。<code class="literal">AHD_data</code>作为参数传递给函数。随机抽样发生。用于训练的数据百分比用<code class="literal">p</code>表示。这里，<code class="literal">p</code>的值是<code class="literal">0.5</code>，这意味着50%的数据用于训练。<code class="literal">List = 'FALSE'</code>避免以列表形式返回数据。然后将结果存储在数据帧分割中:</p><pre class="programlisting">
<strong>    &gt; split &lt;- createDataPartition(y=AHD_data$AHD, p = 0.5, list=FALSE)</strong>
</pre><p>对数据框<code class="literal">split</code>的调用显示了用于训练目的的训练集数据:</p><pre class="programlisting">
<strong>    &gt; split</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_06_004.jpg" alt="Step 3 - preparing the data"/></div><p>
</p><p>将创建训练数据。<code class="literal">split</code>数据帧用于创建训练数据。<code class="literal">train</code>数据帧用于存储训练数据的值:</p><pre class="programlisting">
<strong>    &gt; train &lt;- AHD_data[split,]</strong>
</pre><p>打印训练数据框:</p><pre class="programlisting">
<strong>    &gt; train</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_06_005.jpg" alt="Step 3 - preparing the data"/></div><p>
</p><p>将创建测试数据。<code class="literal">split</code>数据框用于创建测试数据。<code class="literal">split</code>数据帧前的<code class="literal">-</code>符号表示所有未被考虑用于训练目的的数据行。测试数据帧用于存储测试数据的值:</p><pre class="programlisting">
<strong>    &gt; test &lt;- AHD_data[-split,]</strong>
</pre><p>打印测试数据帧:</p><pre class="programlisting">
<strong>    &gt; test</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_06_006.jpg" alt="Step 3 - preparing the data"/></div><p>
</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec84"/>第4步-训练模型</h3></div></div></div><p>现在将在训练数据集上准备和训练模型。与调查数字响应及其与一组描述符变量的关系相比，当数据集被分组时，使用决策树。使用<code class="literal">tree()</code>函数实现R中的分类树。</p><p><code class="literal">tree()</code>函数用于实现分类树。树是通过二进制递归划分生长的。训练数据集上的<code class="literal">AHD</code>字段用于形成分类树。结果数据帧存储在<code class="literal">trees</code>数据帧中:</p><pre class="programlisting">
<strong>    &gt; trees &lt;- tree(AHD ~., train)</strong>
</pre><p>将显示树木数据框的图形版本。<code class="literal">plot()</code>功能是绘制R对象的通用功能。树数据框作为函数值传递:</p><pre class="programlisting">
<strong>    &gt; plot(trees)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_06_007.jpg" alt="Step 4 - training the model"/></div><p>
</p><p>通过交叉验证实验找出偏差或错误分类的数量。将使用<code class="literal">cv.tree()</code>功能。<code class="literal">trees</code>数据框对象通过。<code class="literal">FUN=prune.misclass</code>通过递归截取最不重要的分割，获得所提供数据帧树的嵌套子树序列。结果存储在<code class="literal">cv.trees</code>数据帧中:</p><pre class="programlisting">
<strong>    &gt; cv.trees &lt;- cv.tree(trees, FUN=prune.misclass)</strong>
</pre><p>打印数据框<code class="literal">cv.trees</code>的结果:</p><pre class="programlisting">
<strong>    &gt; cv.trees</strong>
</pre><p><code class="literal">$dev</code>字段给出了每个k的偏差。</p><p>结果如下:</p><p>
</p><div><img src="img/image_06_008.jpg" alt="Step 4 - training the model"/></div><p>
</p><p>使用<code class="literal">plot()</code>功能数据框，显示<code class="literal">cv.trees</code>。<code class="literal">$dev</code>值在<em> y </em>轴上(右侧)。<code class="literal">$k</code>值在最上面。<code class="literal">$size</code>值在<em> x </em>轴上。</p><p>可以清楚的看到，当<code class="literal">$size = 1</code>、<code class="literal">$k = 30.000000</code>、<code class="literal">$dev = 1</code>时。我们使用以下公式绘制数据框:</p><pre class="programlisting">
<strong>    &gt; plot(cv.trees)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_06_009.jpg" alt="Step 4 - training the model"/></div><p>
</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec85"/>第五步——改进模型</h3></div></div></div><p>让我们通过分裂具有最低偏差的树来改进模型。调用<code class="literal">prune.misclass()</code>函数来分割树。<code class="literal">prune.misclass</code>通过递归截取最不重要的分割，获得所提供数据帧树的嵌套子树序列。结果存储在<code class="literal">prune.trees</code>数据帧中。<code class="literal">best=4</code>表示要返回的成本复杂度序列中特定子树的大小(例如，终端节点数):</p><pre class="programlisting">
<strong>    &gt; prune.trees &lt;- prune.misclass(trees, best=4)</strong>
</pre><p>使用<code class="literal">plot()</code>功能数据框，显示<code class="literal">prune.trees</code>:</p><pre class="programlisting">
<strong>    &gt; plot(prune.trees)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_06_010.jpg" alt="Step 5- improving the model"/></div><p>
</p><p>将文本添加到先前修剪的树中:</p><pre class="programlisting">
<strong>    &gt; text(prune.trees, pretty=0)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_06_011.jpg" alt="Step 5- improving the model"/></div><p>
</p><p>为了预测基于线性模型对象的值，我们将使用<code class="literal">predict()</code>函数。<code class="literal">prune.trees</code>作为对象传递。<code class="literal">test</code>数据对象作为一个对象传递，在其中查找要预测的变量。结果将存储在<code class="literal">tree.pred</code>数据框中:</p><pre class="programlisting">
<strong>    &gt; tree.pred &lt;- predict(prune.trees, test, type='class')</strong>
</pre><p>显示变量<code class="literal">test.pred</code>的值:</p><pre class="programlisting">
<strong>    &gt; tree.pred</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_06_012.jpg" alt="Step 5- improving the model"/></div><p>
</p><p>总结模型的结果。<code class="literal">confusionMatrix()</code>计算观察类和预测类的交叉列表。<code class="literal">tree.pred</code>是作为预测类的因素传递的:</p><pre class="programlisting">
<strong>    &gt; confusionMatrix(tree.pred, test$AHD)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_06_013.jpg" alt="Step 5- improving the model"/></div><p>
</p></div></div></div>





<title>Decision tree learning - income-based distribution of real estate values</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="ch06lvl1sec31"/>决策树学习-基于收入的房地产价值分布</h1></div></div></div><p>收入一直是房地产作为一种资产类别提供的有吸引力的长期总回报的重要组成部分。投资房地产产生的年收益回报是股票和滞后债券的2.5倍以上，仅高出50个基点。基于租户支付的租金，房地产通常提供稳定的收入来源。</p><div><div><div><div><h2 class="title">做好准备</h2></div></div></div><p>为了执行决策树分类，我们将使用从房地产数据集收集的数据集。</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec86"/>步骤1 -收集和描述数据</h3></div></div></div><p>将使用名为<code class="literal">RealEstate.txt</code>的数据集。该数据集以TXT格式提供，标题为<code class="literal">RealEstate.txt</code>。数据集采用标准格式。有20，640行数据。9个数值变量如下:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">MedianHouseValue</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">MedianIncome</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">MedianHouseAge</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">TotalRooms</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">TotalBedrooms</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Population</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Households</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Latitude</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Longitude</code></li></ul></div></div></div><div><div><div><div><h2 class="title">如何去做...</h2></div></div></div><p>让我们进入细节。</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec87"/>第2步-探索数据</h3></div></div></div><p>作为要执行的第一步，需要加载以下软件包:</p><pre class="programlisting">
<strong>    &gt; install.packages("tree")</strong>
</pre><div><div><h3 class="title"><a id="note14"/>注意</h3><p>版本信息:此页面的代码在R版本3.3.0中进行了测试(2016-05-03)。</p></div></div><p>让我们探索数据，了解变量之间的关系。我们将从导入名为<code class="literal">RealEstate.txt</code>的TXT数据文件开始。我们将把数据保存到<code class="literal">realEstate</code>数据框:</p><pre class="programlisting">
<strong>    &gt; realEstate &lt;- read.table("d:/RealEstate.txt", header=TRUE)</strong>
</pre><p>探索<code class="literal">realEstate</code>数据框的尺寸。<code class="literal">dim()</code>函数返回<code class="literal">realEstate</code>框架的尺寸。<code class="literal">realEstate</code>数据帧作为输入参数传递。结果清楚地表明有20，640行数据和9列:</p><pre class="programlisting">
<strong>    &gt; dim(realEstate)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_06_014.jpg" alt="Step 2 - exploring the data"/></div><p>
</p><p>探索<code class="literal">realEstate</code>数据帧的内部结构。<code class="literal">str()</code>功能显示数据帧的内部结构。<code class="literal">realEstate</code>作为R对象传递给<code class="literal">str()</code>函数:</p><pre class="programlisting">
<strong>    &gt; str(realEstate)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_06_015.jpg" alt="Step 2 - exploring the data"/></div><p>
</p><p>打印<code class="literal">realEstate</code>数据框。<code class="literal">head()</code>函数返回<code class="literal">realEstate</code>数据帧的第一部分。<code class="literal">realEstate</code>数据帧作为输入参数传递:</p><pre class="programlisting">
<strong>    &gt; head(realEstate)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_06_016.jpg" alt="Step 2 - exploring the data"/></div><p>
</p><p>打印<code class="literal">realEstate</code>数据帧的摘要。<code class="literal">summary()</code>功能是多功能功能。<code class="literal">summary()</code>是一个通用函数，提供与单个对象或数据帧相关的数据汇总。<code class="literal">realEstate</code>数据帧作为R对象传递给<code class="literal">summary()</code>函数:</p><pre class="programlisting">
<strong>    &gt; summary(realEstate)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_06_017.jpg" alt="Step 2 - exploring the data"/></div><p>
</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec88"/>第3步-训练模型</h3></div></div></div><p>现在将在数据集上准备模型。决策树是一种分类和预测的工具。它们代表了人类可以理解的规则，并用于知识系统，如数据库。他们通过从树的根开始并穿过它直到到达一个叶节点来分类实例。节点指定对单个属性的测试，叶子指示目标属性的值，而边则分离出一个属性。</p><p><code class="literal">tree()</code>函数用于实现分类树。树是通过二进制递归划分生长的。这些模型是计算密集型技术，因为它们基于响应变量与一个或多个预测变量的关系递归地将响应变量划分为子集。</p><p>公式表达式基于变量<code class="literal">Latitude</code>和<code class="literal">Longitude</code>的总和。求和的结果存储在<code class="literal">MedianHouseValue</code>的对数值中。<code class="literal">data=realEstate</code>表示优先解释公式、权重和子集的数据框架。</p><p>结果数据帧存储在数据帧<code class="literal">treeModel</code>中:</p><pre class="programlisting">
<strong>    &gt; treeModel &lt;- tree(log(MedianHouseValue) ~ Longitude + Latitude, data=realEstate) </strong>
</pre><p>将显示<code class="literal">treeModel</code>的摘要。该摘要显示所使用的公式，以及树中的终端节点或叶子的数量。还显示了残差的统计分布。</p><p><code class="literal">summary()</code>功能用于显示<code class="literal">treeModel</code>的统计汇总。它是一个通用工具，用于生成各种拟合函数的结果汇总。需要汇总的数据帧是作为输入参数传递的<code class="literal">treeModel</code>。</p><p>这里的偏差是指均方误差:</p><pre class="programlisting">
<strong>    &gt; summary(treeModel)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_06_018.jpg" alt="Step 3 - training the model"/></div><p>
</p><p>将显示<code class="literal">treeModel</code>数据框的图形版本。<code class="literal">plot()</code>功能是用于绘制R对象的通用功能。<code class="literal">treeModel</code>数据帧作为函数值传递:</p><pre class="programlisting">
<strong>    &gt; plot(treeModel) </strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_06_019.jpg" alt="Step 3 - training the model"/></div><p>
</p><p>显示<code class="literal">treeModel</code>数据框的图形版本后，需要插入文本以显示每个节点和叶子的值。<code class="literal">text()</code>函数用于在给定坐标处插入标签向量中给定的字符串:</p><pre class="programlisting">
<strong>    &gt; text(treeModel, cex=.75)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_06_020.jpg" alt="Step 3 - training the model"/></div><p>
</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec89"/>第4步-比较预测</h3></div></div></div><p>将预测与反映全球价格趋势的数据集进行比较。我们希望总结<code class="literal">MedianHouseValue</code>的频率分布，以便于报告或比较。最直接的方法是使用分位数。分位数是分布中与该分布中值的等级顺序相关的点。分位数将划分<code class="literal">MedianHouseValue</code>分布，使得分位数以下有给定比例的观察值。</p><p><code class="literal">quantile()</code>函数产生对应于给定概率的样本分位数。<code class="literal">realEstate$MedianHouseValue</code>是需要其样本分位数的数值向量。<code class="literal">quantile()</code>函数返回<code class="literal">priceDecilesas</code>一个长度向量:</p><pre class="programlisting">
<strong>    &gt; priceDeciles &lt;- quantile(realEstate$MedianHouseValue, 0:10/10)</strong>
</pre><p>显示<code class="literal">priceDeciles</code>数据帧的值:</p><pre class="programlisting">
<strong>    &gt; priceDeciles</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_06_021.jpg" alt="Step 4 - comparing the predictions"/></div><p>
</p><p>接下来，将显示<code class="literal">priceDeciles</code>的摘要。<code class="literal">summary()</code>功能用于显示<code class="literal">priceDeciles</code>的统计汇总。需要汇总的数据帧是作为输入参数传递的<code class="literal">priceDeciles</code>:</p><pre class="programlisting">
<strong>    &gt; summary(priceDeciles)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_06_022.jpg" alt="Step 4 - comparing the predictions"/></div><p>
</p><p>将<code class="literal">priceDeciles</code>向量分成不同的范围。<code class="literal">cut()</code>功能根据音程所属的音程来划分音程的范围。<code class="literal">realEstate</code>数据帧的数值矢量<code class="literal">MedianHouseValue</code>将通过切割转换成一个因子:</p><pre class="programlisting">
<strong>    &gt; cutPrices &lt;- cut(realEstate$MedianHouseValue, priceDeciles, include.lowest=TRUE)</strong>
</pre><p>打印<code class="literal">cutPrices</code>数据帧。<code class="literal">head()</code>函数返回<code class="literal">cutPrices</code>数据帧的第一部分。<code class="literal">cutPrices</code>数据帧作为输入参数传递:</p><pre class="programlisting">
<strong>    &gt; head(cutPrices)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_06_023.jpg" alt="Step 4 - comparing the predictions"/></div><p>
</p><p>将显示<code class="literal">cutPrices</code>的摘要。<code class="literal">summary()</code>功能用于显示<code class="literal">treeModel</code>的统计汇总。需要汇总的数据帧是<code class="literal">cutPrices</code>，作为输入参数传递:</p><pre class="programlisting">
<strong>    &gt; summary(cutPrices)</strong>
</pre><p>结果如下:</p><p>绘制<code class="literal">cutPrices</code>的值。<code class="literal">plot()</code>函数是绘制R对象的通用函数。<code class="literal">cutPrices</code>数据帧作为函数值传递。<code class="literal">realEstate</code>数据集的经度变量代表图中点的<em> x </em>坐标。<code class="literal">realEstate</code>数据集的纬度变量代表图中点的<em> y </em>坐标。<code class="literal">col=grey(10:2/11)</code>代表地块颜色。<code class="literal">pch=20</code>表示在绘图点中用作默认值的符号的大小。<code class="literal">xlab="Longitude"</code>代表x轴的标题，而<code class="literal">ylab="Latitude"</code>代表<em> y </em>轴的标题:</p><div><img src="img/image_06_024.jpg" alt="Step 4 - comparing the predictions"/></div><p>结果如下:</p><p>Plotting the value of the <code class="literal">cutPrices</code>. The <code class="literal">plot()</code> function is a generic function for the plotting of R objects. The <code class="literal">cutPrices</code> data frame is passed as a function value. The longitude variable of the <code class="literal">realEstate</code> dataset represents the <em>x</em> coordinates of points in the plot. The latitude variable of the <code class="literal">realEstate</code> dataset represents the <em>y</em> coordinates of points in the plot. <code class="literal">col=grey(10:2/11)</code> represents the plot color. <code class="literal">pch=20</code> represents the size of the symbol to be used as the default in plotting points. <code class="literal">xlab="Longitude"</code> represents the title for the x axis, while <code class="literal">ylab="Latitude"</code> represents the title for the <em>y</em> axis:</p><pre class="programlisting">
<strong>    &gt; plot(realEstate$Longitude, realEstate$Latitude, col=grey(10:2/11)[cutPrices], pch=20, xlab="Longitude",ylab="Latitude") </strong>
</pre><p>The result is as follows:</p><p>将显示<code class="literal">Longitude</code>的摘要。<code class="literal">summary()</code>功能用于显示统计摘要:</p><div><img src="img/image_06_025.jpg" alt="Step 4 - comparing the predictions"/></div><p>结果如下:</p><p>A summary of <code class="literal">Longitude</code> will be displayed. The <code class="literal">summary()</code> function is used to display the statistical summary:</p><pre class="programlisting">
<strong>    &gt; summary(realEstate$Longitude)</strong>
</pre><p>The result is as follows:</p><p>打印<code class="literal">Longitude</code>数据帧。<code class="literal">head()</code>函数返回<code class="literal">Longitude</code>数据帧的第一部分:</p><div><img src="img/image_06_026.jpg" alt="Step 4 - comparing the predictions"/></div><p>结果如下:</p><p>Printing the <code class="literal">Longitude</code> data frame. The <code class="literal">head()</code> function returns the first part of the <code class="literal">Longitude</code> data frame:</p><pre class="programlisting">
<strong>    &gt; head(realEstate$Longitude)</strong>
</pre><p>The result is as follows:</p><p>将显示<code class="literal">Latitude</code>的摘要。<code class="literal">summary()</code>功能用于显示统计摘要:</p><div><img src="img/image_06_027.jpg" alt="Step 4 - comparing the predictions"/></div><p>结果如下:</p><p>A summary of <code class="literal">Latitude</code> will be displayed. The <code class="literal">summary()</code> function is used to display the statistical summary:</p><pre class="programlisting">
<strong>    &gt; summary(realEstate$Latitude)</strong>
</pre><p>The result is as follows:</p><p>打印<code class="literal">Latitude</code>数据帧。<code class="literal">head()</code>函数返回<code class="literal">Latitude</code>数据帧的第一部分:</p><div><img src="img/image_06_028.jpg" alt="Step 4 - comparing the predictions"/></div><p>结果如下:</p><p>Printing the <code class="literal">Latitude</code> data frame. The <code class="literal">head()</code> function returns the first part of the <code class="literal">Latitude</code> data frame:</p><pre class="programlisting">
<strong>    &gt; head(realEstate$Latitude)</strong>
</pre><p>The result is as follows:</p><p><code class="literal">partition.tree()</code>函数用于划分包含两个或更多变量的树。<code class="literal">treeModel</code>作为树对象传递。<code class="literal">ordvars=c("Longitude","Latitude")</code>表示变量用于绘图的顺序。经度代表<em> x </em>轴，而<code class="literal">Latitude</code>代表y轴。<code class="literal">add=TRUE</code>表示在现有地块上增加:</p><div><img src="img/image_06_029.jpg" alt="Step 4 - comparing the predictions"/></div><p>结果如下:</p><p>The <code class="literal">partition.tree()</code> function is used to partition a tree where two or more variables are involved. <code class="literal">treeModel</code> is passed as a tree object. <code class="literal">ordvars=c("Longitude","Latitude")</code> indicates the ordering in which the variables are to be used to plot. Longitude represents the <em>x</em> axis, while <code class="literal">Latitude</code> represents the y axis. <code class="literal">add=TRUE</code> means adding to the existing plot:</p><pre class="programlisting">
<strong>    &gt; partition.tree(treeModel, ordvars=c("Longitude","Latitude"), add=TRUE)</strong>
</pre><p>The result is as follows:</p><p><a id="ch06lvl3sec90"/>第5步-改进模型</p><div><img src="img/image_06_030.jpg" alt="Step 4 - comparing the predictions"/></div><p>一棵树的叶子数量控制着树的灵活性。叶子的数量表明它们将树分成了多少个单元。每个节点必须包含一定数量的点，增加一个节点必须至少减少一定数量的误差。<code class="literal">min.dev</code>的默认值为0.01。</p></div><div><div><div><div><h3 class="title">接下来，我们将把<code class="literal">min.dev</code>的值减小到0.001。</h3></div></div></div><p><code class="literal">tree()</code>函数用于实现分类树。公式表达式基于变量<code class="literal">Latitude</code>和<code class="literal">Longitude</code>的总和。求和的结果存储在<code class="literal">MedianHouseValue</code>的对数值中。<code class="literal">data=realEstate</code>表示优先解释公式、权重和子集的数据框架。<code class="literal">min.dev</code>的值表示偏差，对于要分裂的节点，该偏差必须至少是根节点的0.001倍。</p><p>结果数据帧存储在<code class="literal">treeModel2</code>数据帧中:</p><p>将显示<code class="literal">treeModel2</code>的摘要。该摘要显示所使用的公式，以及树中的终端节点或叶子的数量。还显示了残差的统计分布。</p><p><code class="literal">summary()</code>功能用于显示<code class="literal">treeModel2</code>的统计汇总。需要汇总的数据帧是作为输入参数传递的<code class="literal">treeModel2</code>。</p><pre class="programlisting">
<strong>    &gt; treeModel2 &lt;- tree(log(MedianHouseValue) ~ Longitude + Latitude, data=realEstate, mindev=0.001)</strong>
</pre><p>这里的偏差是指均方误差:</p><p>结果如下:</p><p>Deviance here means the mean squared error:</p><pre class="programlisting">
<strong>    &gt; summary(treeModel2)</strong>
</pre><p>The result is as follows:</p><p>与<code class="literal">treeModel</code>的总结相比，<code class="literal">treeModel2</code>中的叶子值从12增加到68。<code class="literal">treeModel</code>和<code class="literal">treeModel2</code>的偏差值分别从0.1666变为0.1052。</p><div><img src="img/image_06_031.jpg" alt="Step 5 - improving the model"/></div><p>将显示<code class="literal">treeModel2</code>数据框的图形版本。<code class="literal">plot()</code>功能是绘制R对象的通用功能。<code class="literal">treeModel2</code>数据帧作为函数值传递:</p><p>结果如下:</p><p>A graphical version of the <code class="literal">treeModel2</code> data frame will be displayed. The <code class="literal">plot()</code> function is a generic function for plotting R objects. The <code class="literal">treeModel2</code> data frame is passed as a function value:</p><pre class="programlisting">
<strong>    &gt; plot(treeModel2)</strong>
</pre><p>The result is as follows:</p><p>显示<code class="literal">treeModel2</code>数据框的图形版本后，需要插入文本以显示每个节点和叶子的值。<code class="literal">text()</code>函数用于在给定坐标处插入矢量标签中给定的字符串:</p><div><img src="img/image_06_032.jpg" alt="Step 5 - improving the model"/></div><p>结果如下:</p><p>After the graphical version of the <code class="literal">treeModel2</code> data frame is displayed, text needs to be inserted to display the value at each node and the leaves. The <code class="literal">text()</code> function is used to insert strings given in the vector labels at the given coordinates:</p><pre class="programlisting">
<strong>    &gt; text(treeModel2, cex=.65)</strong>
</pre><p>The result is as follows:</p><p>包括公式扩展中的所有变量。</p><div><img src="img/image_06_033.jpg" alt="Step 5 - improving the model"/></div><p><code class="literal">tree()</code>函数用于实现分类树。公式表达式基于所有变量。</p><p>产生的数据帧存储在<code class="literal">treeModel3</code>数据帧中:</p><p>将显示<code class="literal">treeModel3</code>的摘要。该摘要显示了所使用的公式以及树中终端节点或叶子的数量。还显示了残差的统计分布。</p><p><code class="literal">summary()</code>功能用于显示<code class="literal">treeModel3</code>的统计汇总。需要汇总的数据帧是作为输入参数传递的<code class="literal">treeModel3</code>。</p><pre class="programlisting">
<strong>    &gt; treeModel3 &lt;- tree(log(MedianHouseValue) ~ ., data=realEstate)</strong>
</pre><p>这里的偏差是指均方误差:</p><p>结果如下:</p><p>Deviance here means the mean squared error:</p><pre class="programlisting">
<strong>    &gt; summary(treeModel3)</strong>
</pre><p>The result is as follows:</p><p>该公式清楚地说明了<code class="literal">realEstate</code>数据集的所有变量。</p><div><img src="img/image_06_034.jpg" alt="Step 5 - improving the model"/></div><p>将显示一个图形版本的<code class="literal">treeModel3</code>数据框。<code class="literal">plot()</code>功能是用于绘制R对象的通用功能。<code class="literal">treeModel3</code>数据帧作为函数值传递:</p><p>结果如下:</p><p>A graphical version of <code class="literal">treeModel3</code> data frame will be displayed. The <code class="literal">plot()</code> function is a generic function for plotting R objects. The <code class="literal">treeModel3</code> data frame is passed as a function value:</p><pre class="programlisting">
<strong>    &gt; plot(treeModel3)</strong>
</pre><p>The result is as follows:</p><p>在显示了图形版本的<code class="literal">treeModel3</code>数据框之后，需要插入文本来显示每个节点和叶子的值。<code class="literal">text()</code>函数用于在给定坐标处插入矢量标签中给定的字符串:</p><div><img src="img/image_06_035.jpg" alt="Step 5 - improving the model"/></div><p>结果如下:</p><p>After a graphical version of the <code class="literal">treeModel3</code> data frame is displayed, text needs to be inserted to display the value at each node and the leaves. The <code class="literal">text()</code> function is used to insert strings given in the vector labels at the given coordinates:</p><pre class="programlisting">
<strong>    &gt; text(treeModel3, cex=.75)</strong>
</pre><p>The result is as follows:</p><p><a id="ch06lvl1sec32"/>决策树学习-预测股票走势</p><div><img src="img/image_06_036.jpg" alt="Step 5 - improving the model"/></div><p>股票交易是统计学家试图解决的最具挑战性的问题之一。有多种技术指标，例如趋势方向、市场中的动量或缺乏动量、潜在利润的波动性以及监控市场中受欢迎程度的成交量指标，等等。这些指标可用于创建高概率交易机会的策略。几天/几周/几个月可以用来发现技术指标之间的关系。可以使用一种高效且耗时较少的工具，例如决策树。决策树的主要优势在于它是一种强大且易于解释的算法，这为我们提供了一个良好的开端。</p></div></div></div>





<title>Decision tree learning - predicting the direction of stock movement</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="ch06lvl2sec36"/>做好准备</h1></div></div></div><p>为了执行决策树分类，我们将使用从股票市场数据集中收集的数据集。</p><div><div><div><div><h2 class="title"><a id="ch06lvl3sec91"/>步骤1 -收集和描述数据</h2></div></div></div><p>要使用的数据集是美国银行在2012年1月1日<sup>到2014年1月1日<sup>之间的每日收盘价。这个数据集可以在https://yahoo.com/上免费获得，我们将从那里下载数据。</sup></sup></p><div><div><div><div><h3 class="title"><a id="ch06lvl2sec37"/>怎么做...</h3></div></div></div><p>让我们进入细节。</p></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl3sec92"/>第2步-探索数据</h2></div></div></div><p>作为要执行的第一步，需要加载以下软件包:</p><div><div><div><div><h3 class="title"><a id="note15"/>注</h3></div></div></div><p>版本信息:此页面的代码在R版本3.3.0中进行了测试(2016-05-03)。</p><pre class="programlisting">
<strong>&gt; install.packages("quantmod")
&gt; install.packages("rpart")
&gt; install.packages("rpart.plot")</strong>
</pre><div><div><h3 class="title">需要安装上述每个库:</h3><p>让我们下载数据。我们将从标记需要数据的时间段的开始和结束日期开始。</p></div></div><p><code class="literal">as.Date()</code>函数用于转换字符表示和代表日历日期的<code class="literal">Date</code>类的对象。</p><pre class="programlisting">
<strong>&gt; library("quantmod")
&gt; library("rpart")
&gt; library("rpart.plot")</strong>
</pre><p>数据集的开始日期存储在<code class="literal">startDate</code>中，它代表日历日期的字符向量表示。表示格式为<em> YYYY-MM-DD </em>:</p><p>数据集的结束日期存储在<code class="literal">endDate</code>中，它代表日历日期的字符向量表示。表示格式为<em> YYYY-MM-DD </em>:</p><p>使用<code class="literal">getSymbols()</code>功能加载数据。该函数从本地或远程的多个源加载数据。数据被提取并保存在指定的<code class="literal">env</code>中。<code class="literal">env</code>的默认值为<code class="literal">.GlobalEnv</code>。<code class="literal">BAC</code>是指定要加载的符号名称的字符向量。<code class="literal">src = yahoo</code>指定采购方法:</p><pre class="programlisting">
<strong>    &gt; startDate = as.Date("2012-01-01")</strong>
</pre><p><a id="ch06lvl3sec93"/>步骤3 -计算指标</p><pre class="programlisting">
<strong>    &gt; endDate = as.Date("2014-01-01")</strong>
</pre><p>计算相对强度指数。它是最近价格上升运动与绝对价格运动的比率。<code class="literal">RSI()</code>功能用于计算相对强度指数。<code class="literal">BAC</code>符号用作价格系列。<code class="literal">n = 3</code>代表移动平均线的周期数。然后将结果存储在<code class="literal">relativeStrengthIndex3</code>数据帧中:</p><pre class="programlisting">
<strong>    &gt; getSymbols("BAC", env = .GlobalEnv,  src = "yahoo", from = startDate, to = endDate)</strong>
</pre></div><div><div><div><div><h3 class="title">显示<code class="literal">relativeStrengthIndex3</code>值:</h3></div></div></div><p>结果如下:</p><pre class="programlisting">
<strong>    &gt; relativeStrengthIndex3 &lt;- RSI(Op(BAC), n= 3) </strong>
</pre><p>Displaying the <code class="literal">relativeStrengthIndex3</code> value:</p><pre class="programlisting">
<strong>    &gt; relativeStrengthIndex3</strong>
</pre><p>The result is as follows:</p><p>计算移动平均数。<strong>指数移动平均线</strong>用于技术分析，作为技术指标。在<strong>简单移动平均线</strong>中，序列中的每个值具有相同的权重。时间序列之外的值不包括在平均值中。但是，指数移动平均线是一种累积计算，包括所有数据。过去的数据值逐渐减少，而最近的数据值贡献更大。</p><div><img src="img/image_06_037.jpg" alt="Step 3 - calculating the indicators"/></div><p><code class="literal">EMA()</code>使用<code class="literal">BAC</code>符号，并用作价格系列。<code class="literal">n = 5</code>代表平均结束的时间周期。然后将结果存储在<code class="literal">exponentialMovingAverage5</code>数据帧中:</p><p>显示<code class="literal">exponentialMovingAverage5</code>值:</p><p>结果如下:</p><pre class="programlisting">
<strong>    &gt; exponentialMovingAverage5 &lt;- EMA(Op(BAC),n=5)</strong>
</pre><p>探索<code class="literal">exponentialMovingAverage5</code>数据框的维度。<code class="literal">dim()</code>函数返回<code class="literal">exponentialMovingAverage5</code>框架的尺寸。<code class="literal">exponentialMovingAverage5</code>数据帧作为输入参数传递。结果清楚地表明有502行数据和1列:</p><pre class="programlisting">
<strong>    &gt; exponentialMovingAverage5</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_06_038.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p><p>探索<code class="literal">exponentialMovingAverage5</code>数据框的内部结构。<code class="literal">str()</code>功能显示数据帧的内部结构。<code class="literal">exponentialMovingAverage5</code>作为R对象传递给<code class="literal">str()</code>函数:</p><pre class="programlisting">
<strong>    &gt; dim(exponentialMovingAverage5)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_06_039.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p><p>计算价格和我们计算出的<code class="literal">exponentialMovingAverage5</code>之间的差异，例如，五年指数移动平均值。结果存储在<code class="literal">exponentialMovingAverageDiff</code>数据帧中:</p><pre class="programlisting">
<strong>    &gt; str(exponentialMovingAverage5)</strong>
</pre><p>比较BAC系列的快速移动平均线和BAC系列的慢速移动平均线。<code class="literal">BAC</code>作为价格矩阵传递。<code class="literal">fast = 12</code>代表快速移动平均线的周期，<code class="literal">slow = 26</code>代表慢速移动平均线的周期，<code class="literal">signal = 9</code>代表移动平均线的信号:</p><p>显示MACD值:</p><div><img src="img/image_06_040.jpg" alt="Step 3 - calculating the indicators"/></div><p>结果如下:</p><p>Calculating the difference between the price and our calculated <code class="literal">exponentialMovingAverage5</code>, for example, the five-year exponential moving average values. The result is stored in the <code class="literal">exponentialMovingAverageDiff</code> data frame:</p><pre class="programlisting">
<strong>    &gt; exponentialMovingAverageDiff &lt;- Op(BAC)-exponentialMovingAverage5</strong>
</pre><p>Comparing the fast-moving average of a BAC series with a slow-moving average of a BAC series. <code class="literal">BAC</code> is passed as the price matrix. <code class="literal">fast = 12</code> represents the periods for fast-moving average, <code class="literal">slow = 26</code> represents the periods for slow-moving average, <code class="literal">signal = 9</code> represents the signal for moving average:</p><pre class="programlisting">
<strong>    &gt; MACD &lt;- MACD(Op(BAC),fast = 12, slow = 26, signal = 9)</strong>
</pre><p>打印MACD数据框。<code class="literal">head()</code>函数返回<code class="literal">MACD</code>数据帧的第一部分。<code class="literal">MACD</code>数据帧作为输入参数传递:</p><pre class="programlisting">
<strong>    &gt; MACD</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_06_041.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p><p>抓住信号线作为指示器。结果存储在<code class="literal">MACDsignal</code>数据帧中:</p><pre class="programlisting">
<strong>    &gt; head(MACD)</strong>
</pre><p>显示<code class="literal">MACDsignal</code>值:</p><p>结果如下:</p><div><img src="img/image_06_042.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p><p>Grabbing the signal line to use as an indicator. The result is stored in the <code class="literal">MACDsignal</code> data frame:</p><pre class="programlisting">
<strong>    &gt; MACDsignal &lt;- MACD[,2]</strong>
</pre><p>确定接近高/低范围的中点。为了确定每天收盘价相对于高/低区间的位置，使用了随机振荡指标。<code class="literal">SMI()</code>功能用于动量指示器。</p><pre class="programlisting">
<strong>    &gt; MACDsignal</strong>
</pre><p><code class="literal">BAC</code>是包含高-低-收盘价的矩阵。<code class="literal">n = 13</code>表示期数。<code class="literal">slow=25</code>表示双重平滑的周期数。<code class="literal">fast=2</code>表示初始平滑的周期数。<code class="literal">signal=9</code>表示信号线的周期数。结果存储在<code class="literal">stochasticOscillator</code>数据框中:</p><p>显示<code class="literal">stochasticOscillator</code>值:</p><div><img src="img/image_06_043.jpg" alt="Step 3 - calculating the indicators"/></div><p>结果如下:</p><p>抓住振荡器作为指示器。结果存储在<code class="literal">stochasticOscillatorSignal</code>数据帧中:</p><p>显示<code class="literal">stochasticOscillatorSignal</code>值:</p><pre class="programlisting">
<strong>    &gt; stochasticOscillator &lt;- SMI(Op(BAC),n=13,slow=25,fast=2,signal=9)</strong>
</pre><p>结果如下:</p><pre class="programlisting">
<strong>    &gt; stochasticOscillator</strong>
</pre><p>The result is as follows:</p><p>
</p><div><img src="img/image_06_044.jpg" alt="Step 3 - calculating the indicators"/></div><p><a id="ch06lvl3sec94"/>步骤4 -准备变量以构建数据集</p><p>计算收盘价和开盘价之间的差额。<code class="literal">Cl</code>代表收盘价，<code class="literal">Op</code>代表开盘价。结果存储在<code class="literal">PriceChange</code>数据框中:</p><pre class="programlisting">
<strong>    &gt; stochasticOscillatorSignal &lt;- stochasticOscillator[,1]</strong>
</pre><p>显示<code class="literal">PriceChange</code>值:</p><pre class="programlisting">
<strong>    &gt; stochasticOscillatorSignal</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_06_045.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p></div><div><div><div><div><h3 class="title">创建二元分类变量。<code class="literal">ifelse()</code>函数使用一个测试表达式来返回值，该值本身是一个向量，并且与测试表达式的长度相同。如果<code class="literal">test</code>表达式<code class="literal">is TRUE</code>的对应值，则返回的向量具有来自<code class="literal">x</code>的元素；如果<code class="literal">test</code>表达式<code class="literal">is FALSE.</code>的对应值，则返回来自<code class="literal">y</code>的元素</h3></div></div></div><p>这里，<code class="literal">PriceChange&gt;0</code>是测试函数，要在逻辑模式下测试。<code class="literal">UP</code>和<code class="literal">DOWN</code>执行逻辑测试。然后将结果存储在<code class="literal">binaryClassification</code>数据帧中:</p><pre class="programlisting">
<strong>    &gt; PriceChange &lt;- Cl(BAC) - Op(BAC)</strong>
</pre><p>显示<code class="literal">binaryClassification</code>值:</p><pre class="programlisting">
<strong>    &gt; PriceChange</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_06_046.jpg" alt="Step 4 - preparing variables to build datasets"/></div><p>
</p><p>探索<code class="literal">binaryClassification</code>数据帧的内部结构。<code class="literal">str()</code>功能显示数据帧的内部结构。<code class="literal">binaryClassification</code>作为R对象传递给<code class="literal">str()</code>函数:</p><p>结果如下:</p><pre class="programlisting">
<strong>    &gt; binaryClassification &lt;- ifelse(PriceChange&gt;0,"UP","DOWN")</strong>
</pre><p>Displaying the <code class="literal">binaryClassification</code> value:</p><pre class="programlisting">
<strong>    &gt; binaryClassification</strong>
</pre><p>The result is as follows:</p><p>创建要使用的数据集。<code class="literal">data.frame()</code>函数用于根据一组紧密耦合的变量创建数据框。这些变量共享矩阵的属性。作为参数传递给<code class="literal">data.frame()</code>的变量有<code class="literal">relativeStrengthIndex3</code>、<code class="literal">exponentialMovingAverageDiff</code>、<code class="literal">MACDsignal</code>、<code class="literal">stochasticOscillator</code>和<code class="literal">binaryClassification</code>。</p><div><img src="img/image_06_047.jpg" alt="Step 4 - preparing variables to build datasets"/></div><p>然后将结果存储在<code class="literal">DataSet</code>数据帧中:</p><p>显示<code class="literal">DataSet</code>值:</p><pre class="programlisting">
<strong>    &gt; str(binaryClassification)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_06_048.jpg" alt="Step 4 - preparing variables to build datasets"/></div><p>
</p><p>打印<code class="literal">DataSet</code>数据帧。<code class="literal">head()</code>函数返回<code class="literal">DataSet</code>数据帧的第一部分。<code class="literal">DataSet</code>数据帧作为输入参数传递:</p><p>结果如下:</p><pre class="programlisting">
<strong>&gt; AAPLDataSetNew &gt;-
data.frame(weekDays,exponentialMovingAverageDiffRound,
binaryClassification) </strong>
</pre><p>探索<code class="literal">DataSet</code>数据帧的内部结构。<code class="literal">str()</code>功能显示数据帧的内部结构。<code class="literal">DataSet</code>作为R对象传递给<code class="literal">str()</code>函数:</p><pre class="programlisting">
<strong>    &gt; DataSet</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_06_049.jpg" alt="Step 4 - preparing variables to build datasets"/></div><p>
</p><p>命名列。<code class="literal">c()</code>函数用于将参数组合成向量。</p><pre class="programlisting">
<strong>    &gt; head(DataSet)</strong>
</pre><p>作为参数传递给<code class="literal">c()</code>的变量有<code class="literal">relativeStrengthIndex3</code>、<code class="literal">exponentialMovingAverageDiff</code>、<code class="literal">MACDsignal</code>、<code class="literal">stochasticOscillator</code>和<code class="literal">binaryClassification</code>:</p><p>显示<code class="literal">colnames(DataSet)</code>值:</p><div><img src="img/image_06_050.jpg" alt="Step 4 - preparing variables to build datasets"/></div><p>结果如下:</p><p>Exploring the internal structure of the <code class="literal">DataSet</code> data frame. The <code class="literal">str()</code> function displays the internal structure of the data frame. The <code class="literal">DataSet</code> is passed as an R object to the <code class="literal">str()</code> function:</p><pre class="programlisting">
<strong>    &gt; str(DataSet)</strong>
</pre><p>The result is as follows:</p><p>删除要计算指标的数据:</p><div><img src="img/image_06_051.jpg" alt="Step 4 - preparing variables to build datasets"/></div><p>显示<code class="literal">DataSet</code>值:</p><p>结果如下:</p><p>The variables passed as parameters to <code class="literal">c()</code> are <code class="literal">relativeStrengthIndex3</code>, <code class="literal">exponentialMovingAverageDiff</code>, <code class="literal">MACDsignal</code>, <code class="literal">stochasticOscillator</code>, and <code class="literal">binaryClassification</code>:</p><pre class="programlisting">
<strong>    &gt; colnames(DataSet) &lt;- c("relativeStrengthIndex3", "exponentialMovingAverageDiff", "MACDsignal", "stochasticOscillator", "binaryClassification")</strong>
</pre><p>Displaying the <code class="literal">colnames(DataSet)</code> value:</p><pre class="programlisting">
<strong>    &gt; colnames(DataSet)</strong>
</pre><p>打印<code class="literal">DataSet</code>数据帧。<code class="literal">head()</code>函数返回<code class="literal">DataSet</code>数据帧的第一部分。<code class="literal">DataSet</code>数据帧作为输入参数传递:</p><p>结果如下:</p><div><img src="img/image_06_052.jpg" alt="Step 4 - preparing variables to build datasets"/></div><p>
</p><p>Eliminating the data where the indicators are to be calculated:</p><pre class="programlisting">
<strong>    &gt; DataSet &lt;- DataSet[-c(1:33),]</strong>
</pre><p>探索<code class="literal">DataSet</code>数据帧的内部结构。<code class="literal">str()</code>功能显示数据帧的内部结构。<code class="literal">DataSet</code>作为R对象传递给<code class="literal">str()</code>函数:</p><pre class="programlisting">
<strong>    &gt; DataSet</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_06_053.jpg" alt="Step 4 - preparing variables to build datasets"/></div><p>
</p><p>探索<code class="literal">DataSet</code>数据框的维度。<code class="literal">dim()</code>函数返回<code class="literal">DataSet</code>框架的尺寸。<code class="literal">DataSet</code>数据帧作为输入参数传递。结果清楚地表明有469行数据和5列:</p><pre class="programlisting">
<strong>    &gt; head(DataSet)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_06_054.jpg" alt="Step 4 - preparing variables to build datasets"/></div><p>
</p><p>构建训练数据集。<code class="literal">DataSet</code>数据框中三分之二的元素将用作训练数据集，而<code class="literal">DataSet</code>数据框中三分之一的元素将用作测试数据集。</p><pre class="programlisting">
<strong>    &gt; str(DataSet)</strong>
</pre><p>训练数据集将存储在<code class="literal">TrainingDataSet</code>中:</p><p>显示<code class="literal">TrainingDataSet</code>值:</p><div><img src="img/image_06_055.jpg" alt="Step 4 - preparing variables to build datasets"/></div><p>结果如下:</p><p>Exploring the dimensions of the <code class="literal">DataSet</code> data frame. The <code class="literal">dim()</code> function returns the dimensions of the <code class="literal">DataSet</code> frame. The <code class="literal">DataSet</code> data frame is passed as an input parameter. The result clearly states that there are 469 rows of data and 5 columns:</p><pre class="programlisting">
<strong>    &gt; dim(DataSet)</strong>
</pre><p>The result is as follows:</p><p>探索<code class="literal">TrainingDataSet</code>数据帧的内部结构。<code class="literal">str()</code>功能显示数据帧的内部结构。<code class="literal">TrainingDataSet</code>作为R对象传递给<code class="literal">str()</code>函数:</p><div><img src="img/image_06_056.jpg" alt="Step 4 - preparing variables to build datasets"/></div><p>结果如下:</p><p>Building a training dataset. Two-thirds of the elements in the <code class="literal">DataSet</code> data frame will be used as a training dataset, while one-third of the elements in the <code class="literal">DataSet</code> data frame will be used as a testing dataset.</p><p>The training dataset will be stored in <code class="literal">TrainingDataSet</code>:</p><pre class="programlisting">
<strong>    &gt; TrainingDataSet &lt;- DataSet[1:312,]</strong>
</pre><p>训练数据集将存储在<code class="literal">TestDataSet</code>中:</p><pre class="programlisting">
<strong>    &gt; TrainingDataSet</strong>
</pre><p>显示<code class="literal">TestDataSet</code>值:</p><p>结果如下:</p><div><img src="img/image_06_057.jpg" alt="Step 4 - preparing variables to build datasets"/></div><p>
</p><p>Exploring the internal structure of the <code class="literal">TrainingDataSet</code> data frame. The <code class="literal">str()</code> function displays the internal structure of the data frame. The <code class="literal">TrainingDataSet</code> is passed as an R object to the <code class="literal">str()</code> function:</p><pre class="programlisting">
<strong>    &gt; str(TrainingDataSet)</strong>
</pre><p>探索<code class="literal">TestDataSet</code>数据帧的内部结构。<code class="literal">str()</code>功能显示数据帧的内部结构。<code class="literal">TestDataSet</code>作为R对象传递给<code class="literal">str()</code>函数:</p><p>结果如下:</p><div><img src="img/image_06_058.jpg" alt="Step 4 - preparing variables to build datasets"/></div><p>
</p><p>The training dataset will be stored in <code class="literal">TestDataSet</code>:</p><pre class="programlisting">
<strong>    &gt; TestDataSet &lt;- DataSet[313:469,]</strong>
</pre><p><a id="ch06lvl3sec95"/>第五步-建立模型</p><pre class="programlisting">
<strong>    &gt; TestDataSet</strong>
</pre><p>通过指定指标建立树模型。将使用<code class="literal">rpart()</code>功能。它将符合模型。<code class="literal">binaryClassification</code>是结果，使用<code class="literal">relativeStrengthIndex3</code>、<code class="literal">exponentialMovingAverageDiff</code>、<code class="literal">MACDsignal</code>和<code class="literal">stochasticOscillator</code>之和作为预测值。<code class="literal">data=TrainingDataSet</code>代表数据帧。<code class="literal">cp=.001</code>代表复杂度参数。该参数的主要作用是通过删除拆分来节省计算时间。然后将结果存储在<code class="literal">DecisionTree</code>数据帧中:</p><p>绘制树模型。<code class="literal">prp()</code>功能将用于绘制<code class="literal">DecisionTree</code>数据框。<code class="literal">type=2</code>垂直移动备用节点:</p><div><img src="img/image_06_059.jpg" alt="Step 4 - preparing variables to build datasets"/></div><p>结果如下:</p><p>Exploring the internal structure of the <code class="literal">TestDataSet</code> data frame. The <code class="literal">str()</code> function displays the internal structure of the data frame. The <code class="literal">TestDataSet</code> is passed as an R object to the <code class="literal">str()</code> function:</p><pre class="programlisting">
<strong>    &gt; str(TestDataSet)</strong>
</pre><p>The result is as follows:</p><p>显示<code class="literal">DecisionTree</code>数据框的<code class="literal">cp</code>表。使用<code class="literal">printcp()</code>功能。<code class="literal">DecisionTree</code>作为输入传递:</p><div><img src="img/image_06_060.jpg" alt="Step 4 - preparing variables to build datasets"/></div><p>结果如下:</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec95"/>Step 5 - building the model</h3></div></div></div><p>Building the tree model by specifying the indicators. The <code class="literal">rpart()</code> function will be used. It will fit the model. <code class="literal">binaryClassification</code> is the outcome, using the sum of <code class="literal">relativeStrengthIndex3</code>, <code class="literal">exponentialMovingAverageDiff</code>, <code class="literal">MACDsignal</code>, and <code class="literal">stochasticOscillator</code> as the predictors. <code class="literal">data=TrainingDataSet</code> represents the data frame. <code class="literal">cp=.001</code> represents the complexity parameter. The main role of the parameter is to save computing time by pruning off splits. The result is then stored in the <code class="literal">DecisionTree</code> data frame:</p><pre class="programlisting">
<strong>    &gt; DecisionTree &lt;- rpart(binaryClassification~relativeStrengthIndex3+exponentialMovingAverageDiff+MACDsignal+stochasticOscillator,data=TrainingDataSet, cp=.001)</strong>
</pre><p>绘制树木的几何平均数。<code class="literal">plotcp()</code>功能已使用。它提供了<code class="literal">DecisionTree</code>数据框交叉验证结果的可视化表示:</p><pre class="programlisting">
<strong>    &gt; prp(DecisionTree,type=2)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/B04714_06_61.jpg" alt="Step 5 - building the model"/></div><p>
</p><p><a id="ch06lvl3sec96"/>第6步-改进模型</p><pre class="programlisting">
<strong>    &gt; printcp(DecisionTree)</strong>
</pre><p>修剪树后改进模型。<code class="literal">prune()</code>是使用的功能。<code class="literal">DecisionTree</code>是作为输入传递的数据帧。<code class="literal">cp=0.041428</code>已被采用，因为这是最低的交叉验证误差值(x误差):</p><p>绘制<code class="literal">tree</code>模型。<code class="literal">prp()</code>功能将用于绘制<code class="literal">DecisionTree</code>数据帧。<code class="literal">type=4</code>垂直移动备用节点:</p><div><img src="img/image_06_062.jpg" alt="Step 5 - building the model"/></div><p>结果如下:</p><p>Plotting the geometric mean for trees. <code class="literal">plotcp()</code> function is used. It provides the visual representation of the cross-validation results of the <code class="literal">DecisionTree</code> data frame:</p><pre class="programlisting">
<strong>    &gt; plotcp(DecisionTree,upper="splits")</strong>
</pre><p>The result is as follows:</p><p>测试模型:</p><div><img src="img/image_06_063.jpg" alt="Step 5 - building the model"/></div><p>结果如下:</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec96"/>Step 6 - improving the model</h3></div></div></div><p>Improving the model after pruning the tree. <code class="literal">prune()</code> is the function used. <code class="literal">DecisionTree</code> is the data frame that is passed as an input. <code class="literal">cp=0.041428</code> has been taken, since this is the lowest cross-validation error value (x error):</p><pre class="programlisting">
<strong>    &gt; PrunedDecisionTree &lt;- prune(DecisionTree,cp=0.041428)</strong>
</pre><p><a id="ch06lvl1sec33"/>朴素贝叶斯——预测股票走势的方向</p><pre class="programlisting">
<strong>    &gt; prp(PrunedDecisionTree, type=4)</strong>
</pre><p>股票交易是统计学家试图解决的最具挑战性的问题之一。有多种技术指标，例如趋势方向、市场中的动量或缺乏动量、潜在利润的波动性以及监控市场中受欢迎程度的成交量指标，等等。这些指标可用于创建高概率交易机会的策略。几天/几周/几个月可以用来发现技术指标之间的关系。可以使用一种高效且耗时较少的工具，例如决策树。决策树的主要优势在于它是一种强大且易于解释的算法，这为我们提供了一个良好的开端。</p><p>准备就绪</p><div><img src="img/image_06_064.jpg" alt="Step 6 - improving the model"/></div><p>为了执行朴素贝叶斯，我们将使用从股票市场数据集中收集的数据集。</p><p><a id="ch06lvl3sec97"/>步骤1 -收集和描述数据</p><pre class="programlisting">
<strong>    &gt; table(predict(PrunedDecisionTree,TestDataSet), TestDataSet[,5],dnn=list('predicted','actual')) </strong>
</pre><p>要使用的数据集是苹果公司在2012年1月1日到2014年1月1日之间的每日收盘价。这个数据集可以在https://www.yahoo.com/<a class="ulink" href="https://www.yahoo.com/">网站</a>上免费获得，我们将从那里下载数据。</p><p><a id="ch06lvl2sec39"/>怎么做...</p><div><img src="img/image_06_065.jpg" alt="Step 6 - improving the model"/></div><p>让我们进入细节。</p></div></div></div>





<title>Naive Bayes - predicting the direction of stock movement</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="ch06lvl3sec98"/>第2步-探索数据</h1></div></div></div><p>作为要执行的第一步，需要加载以下软件包:</p><div><div><div><div><h2 class="title"><a id="note16"/>注意</h2></div></div></div><p>版本信息:此页面的代码在R版本3.3.0中进行了测试(2016-05-03)</p><div><div><div><div><h3 class="title">需要安装以下每个库:</h3></div></div></div><p>让我们下载数据。我们将从标记需要数据的时间段的开始和结束日期开始。</p></div></div><div><div><div><div><h2 class="title"><code class="literal">as.Date()</code>函数用于转换代表日历日期的<em> Date </em>类的字符表示和对象。</h2></div></div></div><p>数据集的开始日期存储在<code class="literal">startDate</code>中，它代表日历日期的字符向量表示。表示格式为<em> YYYY-MM-DD </em>:</p><div><div><div><div><h3 class="title">数据集的结束日期存储在<code class="literal">endDate</code>中，它代表日历日期的字符向量表示。表示格式为YYYY-MM-DD:</h3></div></div></div><p>使用<code class="literal">getSymbols()</code>功能加载数据。该函数从本地或远程的多个源加载数据。数据被提取并保存在指定的<code class="literal">env</code>中。<code class="literal">env</code>的默认值为<code class="literal">.GlobalEnv</code>。<code class="literal">AAPL</code>是字符向量，指定要加载的符号的名称。<code class="literal">src = yahoo</code>指定采购方法:</p><pre class="programlisting">
<strong>    &gt; install.packages("quantmod")</strong>
<strong>    &gt; install.packages("lubridate")</strong>
<strong>    &gt; install.packages("e1071")</strong>
</pre><div><div><h3 class="title">探索一周中有数据可用的日子。使用<code class="literal">wday()</code>功能。该函数以十进制格式返回星期几。<code class="literal">AAPL</code>代表数据帧。<code class="literal">label = TRUE</code>将星期几显示为字符串，例如，星期日。然后将结果存储在<code class="literal">weekDays</code>数据帧中:</h3><p>打印<code class="literal">weekDays</code>数据框。<code class="literal">head()</code>函数返回<code class="literal">weekDays</code>数据帧的第一部分。<code class="literal">weekDays</code>数据帧作为输入参数传递:</p></div></div><p>结果如下:</p><pre class="programlisting">
<strong>    &gt; library("quantmod")</strong>
<strong>    &gt; library("lubridate")</strong>
<strong>    &gt; library("e1071")</strong>
</pre><p>Let's download the data. We will begin by marking the start and end date for the time period in which the data is desired.</p><p>The <code class="literal">as.Date()</code> function is used to convert the character representation and objects of the <em>Date</em> class, which represents the calendar dates.</p><p><a id="ch06lvl3sec99"/>步骤3 -准备变量以构建数据集</p><pre class="programlisting">
<strong>    &gt; startDate = as.Date("2012-01-01")</strong>
</pre><p>计算收盘价和开盘价之间的差额。<code class="literal">Cl</code>代表收盘价，<code class="literal">Op</code>代表开盘价。结果存储在<code class="literal">changeInPrices</code>数据帧中:</p><pre class="programlisting">
<strong>    &gt; endDate = as.Date("2014-01-01")</strong>
</pre><p>打印<code class="literal">changeInPrices</code>数据帧。<code class="literal">head()</code>函数返回<code class="literal">changeInPrices</code>数据帧的第一部分。<code class="literal">changeInPrices</code>数据帧作为输入参数传递:</p><pre class="programlisting">
<strong>    &gt; getSymbols("AAPL", env = .GlobalEnv, src = "yahoo", from = startDate,  to = endDate)</strong>
</pre><p>结果如下:</p><div><img src="img/image_06_066.jpg" alt="Step 2 - exploring the data"/></div><p>
</p><p>Exploring the days of the week when data is available. The <code class="literal">wday()</code> function is used. The function returns the day of the week in decimal format. <code class="literal">AAPL</code> represents the data frame. <code class="literal">label = TRUE</code> displays the day of the week as a character string, for example, Sunday. The result is then stored in the <code class="literal">weekDays</code> data frame:
</p><pre class="programlisting">
<strong>    &gt; weekDays &lt;- wday(AAPL, label=TRUE)</strong>
</pre><p>探索价格变化的汇总。使用<code class="literal">summary()</code>功能。该函数提供一系列描述性统计数据，以生成<code class="literal">changeInPrices</code>数据帧的结果汇总:</p><pre class="programlisting">
<strong>    &gt; head(weekDays)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_06_067.jpg" alt="Step 2 - exploring the data"/></div><p>
</p></div><div><div><div><div><h3 class="title">探索<code class="literal">changeInPrices</code>数据框的尺寸。<code class="literal">dim()</code>函数返回<code class="literal">changeInPrices</code>框架的尺寸。<code class="literal">changeInPrices</code>数据帧作为输入参数传递。结果清楚地表明有502行数据和1列:</h3></div></div></div><p>结果如下:</p><pre class="programlisting">
<strong>    &gt; changeInPrices &lt;- Cl(AAPL) - Op(AAPL)</strong>
</pre><p>Printing the <code class="literal">changeInPrices</code> data frame. The <code class="literal">head()</code> function returns the first part of the <code class="literal">changeInPrices</code> data frame. The <code class="literal">changeInPrices</code> data frame is passed as an input parameter:</p><pre class="programlisting">
<strong>    &gt; head(changeInPrices)</strong>
</pre><p>The result is as follows:</p><p>创建二元分类变量。<code class="literal">ifelse()</code>函数使用一个测试表达式来返回值，该值本身是一个向量，并且与测试表达式的长度相同。如果测试表达式的对应值是<code class="literal">TRUE</code>，则返回的向量具有来自<code class="literal">x</code>的元素，或者如果测试表达式的对应值是<code class="literal">FALSE</code>，则返回来自<code class="literal">y</code>的元素。</p><div><img src="img/image_06_068.jpg" alt="Step 3 - preparing variables to build datasets"/></div><p>这里，<code class="literal">changeInPrices&gt;0</code>是测试逻辑模式的测试功能。<code class="literal">UP</code>和<code class="literal">DOWN</code>执行逻辑测试。然后将结果存储在<code class="literal">binaryClassification</code>数据帧中:</p><p>显示<code class="literal">binaryClassification</code>值:</p><pre class="programlisting">
<strong>    &gt; summary(changeInPrices)</strong>
</pre><p>结果如下:</p><p>探索价格变化的汇总。使用<code class="literal">summary()</code>功能。该函数提供了一系列描述性统计数据，以生成<code class="literal">binaryClassification</code>数据帧的结果汇总:</p><div><img src="img/image_06_069.jpg" alt="Step 3 - preparing variables to build datasets"/></div><p>结果如下:</p><p>Exploring the dimensions of the <code class="literal">changeInPrices</code> data frame. The <code class="literal">dim()</code> function returns the dimensions of the <code class="literal">changeInPrices</code> frame. The <code class="literal">changeInPrices</code> data frame is passed as an input parameter. The result clearly states that there are 502 rows of data and 1 column:</p><pre class="programlisting">
<strong>    &gt; dim(changeInPrices)</strong>
</pre><p>The result is as follows:</p><p>创建要使用的数据集。<code class="literal">data.frame()</code>函数用于根据一组紧密耦合的变量创建数据框。这些变量共享矩阵的属性。</p><div><img src="img/image_06_070.jpg" alt="Step 3 - preparing variables to build datasets"/></div><p>作为参数传递给<code class="literal">data.frame()</code>的变量是<code class="literal">weekDays</code>和<code class="literal">binaryClassification</code>。然后将结果存储在<code class="literal">DataSet</code>数据帧中:</p><p>显示<code class="literal">AAPLDataSet</code>值:</p><p>结果如下:</p><pre class="programlisting">
<strong>    &gt; binaryClassification &lt;- ifelse(changeInPrices&gt;0,"UP","DOWN")</strong>
</pre><p>Displaying the <code class="literal">binaryClassification</code> value:</p><pre class="programlisting">
<strong>    &gt; binaryClassification</strong>
</pre><p>The result is as follows:</p><p>打印<code class="literal">AAPLDataSet</code>数据帧。<code class="literal">head()</code>函数返回<code class="literal">AAPLDataSet</code>数据帧的第一部分。<code class="literal">AAPLDataSet</code>数据帧作为输入参数传递:</p><div><img src="img/image_06_071.jpg" alt="Step 3 - preparing variables to build datasets"/></div><p>结果如下:</p><p>Exploring the summary of change in prices. The <code class="literal">summary()</code> function is used. The function provides a range of descriptive statistics to produce result summaries of the <code class="literal">binaryClassification</code> data frame:</p><pre class="programlisting">
<strong>    &gt; summary(binaryClassification)</strong>
</pre><p>The result is as follows:</p><p>探索<code class="literal">AAPLDataSet</code>数据框的尺寸。<code class="literal">dim()</code>函数返回<code class="literal">AAPLDataSet</code>数据框的尺寸。<code class="literal">AAPLDataSet</code>数据帧作为输入参数传递。结果清楚地表明有502行数据和2列:</p><div><img src="img/image_06_072.jpg" alt="Step 3 - preparing variables to build datasets"/></div><p>结果如下:</p><p>Creating the dataset to be used. The <code class="literal">data.frame()</code> function is used to create data frames based on a tightly coupled set of variables. These variables share the properties of matrices.</p><p>The variables passed as parameters to <code class="literal">data.frame()</code> are <code class="literal">weekDays</code> and 
<code class="literal">binaryClassification</code>. The result is then stored in the <code class="literal">DataSet</code> data frame:</p><pre class="programlisting">
<strong>    &gt; AAPLDataSet &lt;- data.frame(weekDays,binaryClassification)</strong>
</pre><p><a id="ch06lvl3sec100"/>第4步-建立模型</p><pre class="programlisting">
<strong>    &gt; AAPLDataSet</strong>
</pre><p>通过指定指标构建朴素贝叶斯分类器。将使用<code class="literal">naiveBayes()</code>功能。在给定独立预测变量的情况下，它使用贝叶斯规则来计算一组给定类别变量的后验概率。该函数假设度量预测值为高斯分布。<code class="literal">NaiveBayesclassifier</code>是函数的结果，其中自变量为<code class="literal">AAPLDataSet[,1]</code>，因变量为<code class="literal">AAPLDataSet[,2]</code>:</p><p>显示<code class="literal">NaiveBayesclassifier</code>结果:</p><div><img src="img/image_06_073.jpg" alt="Step 3 - preparing variables to build datasets"/></div><p>结果如下:</p><p>Printing the <code class="literal">AAPLDataSet</code> data frame. The <code class="literal">head()</code> function returns the first part of the <code class="literal">AAPLDataSet</code> data frame. The <code class="literal">AAPLDataSet</code> data frame is passed as an input parameter:</p><pre class="programlisting">
<strong>    &gt; head(AAPLDataSet)</strong>
</pre><p>The result is as follows:</p><p>结果覆盖整个数据集，并显示价格上涨或下跌的概率。本质上是看跌的。</p><div><img src="img/image_06_074.jpg" alt="Step 3 - preparing variables to build datasets"/></div><p><a id="ch06lvl3sec101"/>第5步——为新的、改进的模型创建数据</p><p>制定一个复杂的策略，展望未来。计算5年期间模型的移动平均值。<code class="literal">EMA()</code>使用AAPL符号作为价格序列。<code class="literal">n = 5</code>代表平均结束的时间周期。然后将结果存储在<code class="literal">exponentialMovingAverage5</code>数据帧中:</p><pre class="programlisting">
<strong>    &gt; dim(AAPLDataSet)</strong>
</pre><p>显示<code class="literal">exponentialMovingAverage5</code>值:</p><p>结果如下:</p><div><img src="img/image_06_075.jpg" alt="Step 3 - preparing variables to build datasets"/></div><p>探索价格变化的汇总。使用<code class="literal">summary()</code>功能。该函数提供了一系列描述性统计数据，以生成<code class="literal">exponentialMovingAverage5 </code>数据帧的结果汇总:</p></div><div><div><div><div><h3 class="title">结果如下:</h3></div></div></div><p>Building the naives Bayes classifier by specifying the indicators. The <code class="literal">naiveBayes()</code> function will be used. It uses the Bayes rule to compute posterior probabilities for a given set of class variables given independent predictor variables. The function assumes a Gaussian distribution of metric predictors. <code class="literal">NaiveBayesclassifier</code> is the outcome of the function, where the independent variable is <code class="literal">AAPLDataSet[,1]</code> and the dependent variable is <code class="literal">AAPLDataSet[,2]</code>
:
</p><pre class="programlisting">
<strong>    &gt; NaiveBayesclassifier &lt;- naiveBayes(AAPLDataSet[,1], AAPLDataSet[,2])</strong>
</pre><p>Displaying the <code class="literal">NaiveBayesclassifier</code> result:</p><pre class="programlisting">
<strong>    &gt; NaiveBayesclassifier</strong>
</pre><p>计算模型在10年内的移动平均值。</p><p><code class="literal">EMA()</code>使用AAPL符号作为价格序列。<code class="literal">n = 10</code>代表平均结束的时间周期。结果存储在<code class="literal">exponentialMovingAverage10</code>数据框中:</p><div><img src="img/image_06_076.jpg" alt="Step 4 - building the model"/></div><p>显示<code class="literal">exponentialMovingAverage10</code>值:</p><p>结果如下:</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec101"/>Step 5 - creating data for a new, improved model</h3></div></div></div><p>Developing a sophisticated strategy, looking ahead more than a day. Calculating moving average to the model for a period of 5 years. <code class="literal">EMA()</code> uses the AAPL symbol as a price series. <code class="literal">n = 5</code> represents the time period to average over. The result is then stored in the <code class="literal">exponentialMovingAverage5</code> data frame:</p><pre class="programlisting">
<strong>    &gt; exponentialMovingAverage5 &lt;- EMA(Op(AAPL),n = 5)</strong>
</pre><p>探索价格变化的汇总。使用<code class="literal">summary()</code>功能。该函数提供了一系列描述性统计数据，以生成<code class="literal">exponentialMovingAverage10</code>数据帧的结果汇总:</p><pre class="programlisting">
<strong>    &gt; exponentialMovingAverage5</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_06_077.jpg" alt="Step 5 - creating data for a new, improved model"/></div><p>
</p><p>探索<code class="literal">exponentialMovingAverage10</code>数据框的尺寸。<code class="literal">dim() </code>函数返回<code class="literal">exponentialMovingAverage10</code>框架的尺寸。<code class="literal">exponentialMovingAverage10</code>数据帧作为输入参数传递。结果清楚地表明有502行数据和1列:</p><pre class="programlisting">
<strong>    &gt; summary(exponentialMovingAverage5)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_06_078.jpg" alt="Step 5 - creating data for a new, improved model"/></div><p>
</p><p>计算<code class="literal">exponentialMovingAverage5</code>和<code class="literal">exponentialMovingAverage10</code>之间的差值:</p><p>显示<code class="literal">exponentialMovingAverageDiff</code>值:</p><pre class="programlisting">
<strong>    &gt; exponentialMovingAverage10 &lt;- EMA(Op(AAPL),n = 10)</strong>
</pre><p>结果如下:</p><pre class="programlisting">
<strong>    &gt; exponentialMovingAverage10</strong>
</pre><p>The result is as follows:</p><p>
</p><div><img src="img/image_06_079.jpg" alt="Step 5 - creating data for a new, improved model"/></div><p>探索价格变化的汇总。使用<code class="literal">summary()</code>功能。该函数提供一系列描述性统计数据，以生成<code class="literal">exponentialMovingAverageDiff</code>数据帧的结果汇总:</p><p>结果如下:</p><pre class="programlisting">
<strong>    &gt; summary(exponentialMovingAverage10)</strong>
</pre><p>The result is as follows:</p><p>
</p><div><img src="img/image_06_080.jpg" alt="Step 5 - creating data for a new, improved model"/></div><p>将<code class="literal">exponentialMovingAverageDiff</code>数据帧四舍五入至两位有效数字:</p><p>探索价格变化的汇总。使用<code class="literal">summary()</code>功能。该函数提供了一系列描述性统计数据，以生成<code class="literal">exponentialMovingAverageDiffRound</code>数据帧的结果汇总:</p><pre class="programlisting">
<strong>    &gt; dim(exponentialMovingAverage10)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_06_081.jpg" alt="Step 5 - creating data for a new, improved model"/></div><p>
</p><p><a id="ch06lvl3sec102"/>第六步——改进模型</p><pre class="programlisting">
<strong>    &gt; exponentialMovingAverageDiff &lt;- exponentialMovingAverage5 - exponentialMovingAverage10</strong>
</pre><p>创建要使用的数据集。<code class="literal">data.frame()</code>函数用于根据一组紧密耦合的变量创建数据框。这些变量共享矩阵的属性。作为参数传递给<code class="literal">data.frame()</code>的变量有<code class="literal">weekDays</code>、<code class="literal">exponentialMovingAverageDiffRound</code>和<code class="literal">binaryClassification</code>。然后将结果存储在<code class="literal">AAPLDataSetNew</code>数据帧中:</p><pre class="programlisting">
<strong>    &gt; exponentialMovingAverageDiff</strong>
</pre><p>显示<code class="literal">AAPLDataSetNew </code>值:</p><p>结果如下:</p><div><img src="img/image_06_082.jpg" alt="Step 5 - creating data for a new, improved model"/></div><p>
</p><p>Exploring the summary of change in prices. The <code class="literal">summary()</code> function is used. The function provides a range of descriptive statistics to produce result summaries of the <code class="literal">exponentialMovingAverageDiff</code> data frame:</p><pre class="programlisting">
<strong>    &gt; summary(exponentialMovingAverageDiff)</strong>
</pre><p>探索价格变化的汇总。使用<code class="literal">summary()</code>功能。该函数提供了一系列描述性统计数据，以生成<code class="literal">AAPLDataSetNew</code>数据框的结果汇总；</p><p>结果如下:</p><div><img src="img/image_06_083.jpg" alt="Step 5 - creating data for a new, improved model"/></div><p>
</p><p>Rounding off the <code class="literal">exponentialMovingAverageDiff</code> data frame to two significant digits:</p><pre class="programlisting">
<strong>    &gt; exponentialMovingAverageDiffRound &lt;- round(exponentialMovingAverageDiff, 2)</strong>
</pre><p>结果如下:</p><pre class="programlisting">
<strong>    &gt; summary(exponentialMovingAverageDiffRound)</strong>
</pre><p>The result is as follows:</p><p>
</p><div><img src="img/image_06_084.jpg" alt="Step 5 - creating data for a new, improved model"/></div><p>探索价格变化的汇总。使用<code class="literal">summary()</code>功能。该函数提供了一系列描述性统计数据，以生成<code class="literal">AAPLDataSetNew</code>数据框的结果汇总；</p></div><div><div><div><div><h3 class="title">结果如下:</h3></div></div></div><p>Creating the dataset to be used. The <code class="literal">data.frame()</code> function is used to create data frames based on a tightly coupled set of variables. These variables share the properties of matrices. The variables passed as parameters to <code class="literal">data.frame()</code> are <code class="literal">weekDays</code>, <code class="literal">exponentialMovingAverageDiffRound</code>, and <code class="literal">binaryClassification</code>. The result is then stored in the <code class="literal">AAPLDataSetNew</code> data frame:</p><pre class="programlisting">
<strong>    &gt; AAPLDataSetNew &lt;- data.frame(weekDays,exponentialMovingAverageDiffRound, binaryClassification) </strong>
</pre><p>Displaying the <code class="literal">AAPLDataSetNew </code>value:</p><pre class="programlisting">
<strong>    &gt; AAPLDataSetNew </strong>
</pre><p>探索<code class="literal">AAPLDataSetNew</code>数据帧的尺寸。<code class="literal">dim()</code>函数返回<code class="literal">AAPLDataSetNew</code>框架的尺寸。<code class="literal">AAPLDataSetNew</code>数据帧作为输入参数传递。结果清楚地表明有492行数据和3列:</p><p>结果如下:</p><div><img src="img/image_06_086.jpg" alt="Step 6 - improving the model"/></div><p>
</p><p>Exploring the summary of change in prices. The <code class="literal">summary()</code> function is used. The function provides a range of descriptive statistics to produce result summaries of the <code class="literal">AAPLDataSetNew</code> data frame:</p><pre class="programlisting">
<strong>    &gt; summary(AAPLDataSetNew)</strong>
</pre><p>构建训练数据集。<code class="literal">AAPLDataSetNew</code>数据框中三分之二的元素将用作训练数据集，而<code class="literal">AAPLDataSetNew</code>数据框中三分之一的元素将用作测试数据集。</p><p>训练数据集将存储在<code class="literal">trainingDataSet</code>数据框中:</p><div><img src="img/image_06_087.jpg" alt="Step 6 - improving the model"/></div><p>探索<code class="literal">trainingDataSet</code>数据框的尺寸。<code class="literal">dim()</code>函数返回<code class="literal">trainingDataSet</code>数据框的尺寸。<code class="literal">trainingDataSet</code>数据帧作为输入参数传递。结果清楚地表明有328行数据和3列:</p><pre class="programlisting">
<strong>    &gt; AAPLDataSetNew &lt;- AAPLDataSetNew[-c(1:10),]</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_06_088.jpg" alt="Step 6 - improving the model"/></div><p>
</p><p>探索价格变化的汇总。使用<code class="literal">trainingDataSet()</code>功能。该函数提供一系列描述性统计数据，以生成<code class="literal">trainingDataSet</code>数据帧的结果汇总:</p><pre class="programlisting">
<strong>    &gt; summary(AAPLDataSetNew) </strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_06_089.jpg" alt="Step 6 - improving the model"/></div><p>
</p><p>训练数据集将存储在<code class="literal">TestDataSet</code>数据框中:</p><pre class="programlisting">
<strong>    &gt; dim(AAPLDataSetNew)</strong>
</pre><p>探索<code class="literal">TestDataSet</code>数据框的尺寸。<code class="literal">dim()</code>函数返回<code class="literal">TestDataSet </code>框架的尺寸。<code class="literal">TestDataSet</code>数据帧作为输入参数传递。结果清楚地表明有164行数据和3列:</p><p>结果如下:</p><div><img src="img/image_06_090.jpg" alt="Step 6 - improving the model"/></div><p>
</p><p>Building a training dataset. Two-thirds of the elements in the <code class="literal">AAPLDataSetNew</code> data frame will be used as the training dataset, while one-third of the elements in the <code class="literal">AAPLDataSetNew</code> data frame will be used as the testing dataset.</p><p>结果如下:</p><pre class="programlisting">
<strong>    &gt; trainingDataSet &lt;- AAPLDataSetNew[1:328,] </strong>
</pre><p>通过指定指标构建朴素贝叶斯分类器。将使用<code class="literal">naiveBayes()</code>功能。在给定独立预测变量的情况下，它使用贝叶斯规则来计算一组给定类别变量的后验概率。该函数假设度量预测值为高斯分布。</p><pre class="programlisting">
<strong>    &gt; dim(trainingDataSet)</strong>
</pre><p><code class="literal">exponentialMovingAverageDiffRoundModel</code>是函数的结果，其中自变量为<code class="literal">trainingDataSet[,1:2]</code>，因变量为<code class="literal">trainingDataSet[,3]</code>:</p><p>显示<code class="literal">exponentialMovingAverageDiffRoundModel</code>结果:</p><div><img src="img/image_06_091.jpg" alt="Step 6 - improving the model"/></div><p>结果如下:</p><p>Exploring the summary of change in prices. The <code class="literal">trainingDataSet()</code> function is used. The function provides a range of descriptive statistics to produce result summaries of the <code class="literal">trainingDataSet</code> data frame:</p><pre class="programlisting">
<strong>    &gt; summary(trainingDataSet)</strong>
</pre><p>The result is as follows:</p><p>测试结果:</p><div><img src="img/image_06_092.jpg" alt="Step 6 - improving the model"/></div><p>结果如下:</p><p>The training dataset will be stored in the <code class="literal">TestDataSet</code> data frame:</p><pre class="programlisting">
<strong>    &gt; TestDataSet &lt;- AAPLDataSetNew[329:492,]</strong>
</pre><p>Exploring the dimensions of the <code class="literal">TestDataSet</code> data frame. The <code class="literal">dim()</code> function returns the dimensions of the <code class="literal">TestDataSet </code>frame. The <code class="literal">TestDataSet</code> data frame is passed as an input parameter. The result clearly states that there are 164 rows of data and 3 columns:</p><pre class="programlisting">
<strong>    &gt; dim(TestDataSet)</strong>
</pre><p><a id="ch06lvl1sec34"/>随机森林货币交易策略</p><p>在进行技术分析后，可以科学地实现预测外汇市场未来价格趋势的目标。外汇交易员根据多种技术分析制定策略，如市场趋势、交易量、交易区间、支撑位和阻力位、图表模式和指标，以及使用不同的时间框架图表进行多时间框架分析。基于对过去市场行为的统计，例如过去的价格和过去的交易量，技术分析策略被创建用于评估资产。分析的主要目标不是衡量一项资产的潜在价值，而是计算由历史表现表明的市场的未来表现。</p><div><img src="img/image_06_093.jpg" alt="Step 6 - improving the model"/></div><p>准备就绪</p><pre class="programlisting">
<strong>    &gt; summary(TestDataSet)</strong>
</pre><p>为了执行随机森林，我们将使用从美元和英镑数据集收集的数据集。</p><p><a id="ch06lvl3sec103"/>步骤1 -收集和描述数据</p><div><img src="img/image_06_094.jpg" alt="Step 6 - improving the model"/></div><p>将使用名为<code class="literal">PoundDollar.csv</code>的数据集。数据集采用标准格式。有5，257行数据和6个变量。数字变量如下:</p><p><code class="literal">Date</code></p><p><code class="literal">Open</code></p><pre class="programlisting">
<strong>&gt; exponentialMovingAverageDiffRoundModel &lt;-
naiveBayes(trainingDataSet[,1:2],trainingDataSet[,3])</strong>
</pre><p><code class="literal">High</code></p><pre class="programlisting">
<strong>    &gt; exponentialMovingAverageDiffRoundModel</strong>
</pre><p><code class="literal">Low</code></p><p><code class="literal">Close</code></p><div><img src="img/image_06_095.jpg" alt="Step 6 - improving the model"/></div><p><code class="literal">Volume</code></p><p><a id="ch06lvl2sec41"/>怎么做...</p><pre class="programlisting">
<strong>    &gt; table(predict(exponentialMovingAverageDiffRoundModel,TestDataSet),</strong>
<strong>TestDataSet[,3],dnn=list('Predicted','Actual')) </strong>
</pre><p>让我们进入细节。</p><p><a id="ch06lvl3sec104"/>第2步-探索数据</p><div><img src="img/image_06_096.jpg" alt="Step 6 - improving the model"/></div><p>作为要执行的第一步，需要加载以下软件包:</p></div></div></div>





<title>Random forest - currency trading strategy</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="note17"/>注意</h1></div></div></div><p>版本信息:此页面的代码在R版本3.3.0中进行了测试(2016-05-03)。</p><div><div><div><div><h2 class="title">需要安装以下每个库:</h2></div></div></div><p>让我们探索数据，了解变量之间的关系。我们将从导入名为<code class="literal">PoundDollar.csv</code>的CSV数据文件开始。我们将把数据保存到<code class="literal">PoundDollar</code>数据框:</p><div><div><div><div><h3 class="title">打印<code class="literal">PoundDollar</code>数据帧。<code class="literal">head()</code>函数返回<code class="literal">PoundDollar</code>数据帧的第一部分。<code class="literal">PoundDollar</code>数据帧作为输入参数传递:</h3></div></div></div><p>结果如下:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Date</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Open</code></li><li class="listitem" style="list-style-type: disc">打印<code class="literal">PoundDollar</code>数据框的摘要。<code class="literal">summary()</code>功能是多功能功能。<code class="literal">summary()</code>是一个通用函数，提供与单个对象或数据框相关的数据汇总。<code class="literal">PoundDollar</code>数据帧作为R对象传递给<code class="literal">summary()</code>函数:</li><li class="listitem" style="list-style-type: disc">结果如下:</li><li class="listitem" style="list-style-type: disc"><code class="literal">Close</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Volume</code></li></ul></div></div></div><div><div><div><div><h2 class="title">探索<code class="literal">PoundDollar</code>数据框的尺寸。<code class="literal">dim()</code>函数返回<code class="literal">PoundDollar</code>框架的尺寸。<code class="literal">PoundDollar</code>数据帧作为输入参数传递。结果清楚地表明有5，257行数据和7列:</h2></div></div></div><p>结果如下:</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec104"/>Step 2 - exploring the data</h3></div></div></div><p>The following packages need to be loaded as the first step to be carried out:</p><pre class="programlisting">
<strong>&gt; install.packages("quantmod")
&gt; install.packages("randomForest")
&gt; install.packages("Hmisc")</strong>
</pre><div><div><h3 class="title"><a id="ch06lvl3sec105"/>步骤3 -准备变量以构建数据集</h3><p>表示日历日期和时间。<code class="literal">as.POSIXlt()</code>函数操纵对象来表示日期和时间。<code class="literal">PoundDollar</code>作为参数传递。<code class="literal">format="%m/%d/%y %H:%M</code>表示日期时间格式。结果存储在<code class="literal">DateAndTime</code>数据框中:</p></div></div><p>捕捉<code class="literal">High</code>、<code class="literal">Low</code>和<code class="literal">Close</code>值:</p><pre class="programlisting">
<strong>&gt; library("quantmod")
&gt; library("randomForest")
&gt; library("Hmisc")</strong>
</pre><p><code class="literal">PoundDollar</code>数据帧捕获位于第四、第五和第六列的<code class="literal">High</code>、<code class="literal">Low</code>和<code class="literal">Close</code>值。打印<code class="literal">HighLowClose</code>数据帧。<code class="literal">head()</code>函数返回<code class="literal">HighLowClose</code>数据帧的第一部分。<code class="literal">HighLowClose</code>数据帧作为输入参数传递:</p><pre class="programlisting">
<strong>    &gt; PoundDollar &lt;- read.csv("d:/PoundDollar.csv")</strong>
</pre><p>结果如下:</p><pre class="programlisting">
<strong>    &gt; head(PoundDollar)</strong>
</pre><p>The result is as follows:</p><p>
</p><div><img src="img/image_06_097.jpg" alt="Step 2 - exploring the data"/></div><p>打印<code class="literal">HighLowClose</code>数据帧的摘要。<code class="literal">summary()</code>功能是多功能功能。<code class="literal">summary()</code>是一个通用函数，提供与单个对象或数据帧相关的数据的汇总。<code class="literal">HighLowClose</code>数据帧作为R对象传递给<code class="literal">summary()</code>函数:</p><p>结果如下:</p><pre class="programlisting">
<strong>    &gt; summary(PoundDollar)</strong>
</pre><p>探索<code class="literal">HighLowClose</code>数据帧的内部结构。<code class="literal">str()</code>功能显示数据帧的内部结构。<code class="literal">HighLowClose</code>作为R对象传递给<code class="literal">str()</code>函数:</p><p>结果如下:</p><div><img src="img/image_06_098.jpg" alt="Step 2 - exploring the data"/></div><p>
</p><p>Exploring the dimensions of the <code class="literal">PoundDollar</code> data frame. The <code class="literal">dim()</code> function returns the dimensions of the <code class="literal">PoundDollar</code> frame. The <code class="literal">PoundDollar</code> data frame is passed as an input parameter. The result clearly states that there are 5,257 rows of data and 7 columns:</p><pre class="programlisting">
<strong>    &gt; dim(PoundDollar)</strong>
</pre><p>创建要使用的数据集。<code class="literal">data.frame()</code>函数用于根据一组紧密耦合的变量创建数据框。这些变量共享矩阵的属性。作为参数传递给<code class="literal">data.frame()</code>的变量是<code class="literal">HighLowClose</code>。然后将结果存储在<code class="literal">HighLowClosets</code>数据帧中。<code class="literal">row.names=DateAndTime</code>表示指定用作行名的列的单个整数字符串。结果存储在<code class="literal">HighLowClose</code>数据帧中:</p><p>描述数据集。<code class="literal">describe()</code>功能提供项目分析。<code class="literal">HighLowClosets</code>作为输入参数传递:</p><div><img src="img/image_06_099.jpg" alt="Step 2 - exploring the data"/></div><p>结果如下:</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec105"/>Step 3 - preparing variables to build datasets</h3></div></div></div><p>Representing calendar dates and times. The <code class="literal">as.POSIXlt()</code> function manipulates the objects to represent date and time. <code class="literal">PoundDollar</code> is passed as an argument. <code class="literal">format="%m/%d/%y %H:%M</code> represents the date-time format. The results are stored in the <code class="literal">DateAndTime</code> data frame:</p><pre class="programlisting">
<strong>    &gt; DateAndTime &lt;- as.POSIXlt(PoundDollar[,2],format="%m/%d/%y %H:%M")</strong>
</pre><p>创建时序对象。使用<code class="literal">as.xts()</code>功能。它将任意类的数据对象转换为类<code class="literal">xts</code>，而不会丢失原始格式的任何属性。<code class="literal">HighLowClosets</code>作为输入对象传递:</p><pre class="programlisting">
<strong>    &gt; HighLowClose &lt;- PoundDollar[,4:6]</strong>
</pre><p>计算布林线。布林线是区间指标，计算移动平均线的标准差。布林线运行的逻辑是，货币对的价格最有可能向其平均价格靠拢，因此，当它偏离太远时，比如偏离两个标准差，它将回撤至其移动平均价格。<code class="literal">BBands()</code>函数用于计算布林线。<code class="literal">HighLowClosexts</code>作为对象传递，该对象被更改为包含盘高-盘低-收盘价的矩阵。<code class="literal">n=20</code>表示移动平均线的周期数。SMA命名要调用的函数。<code class="literal">sd=2</code>表示两个标准偏差:</p><pre class="programlisting">
<strong>    &gt; head(HighLowClose)</strong>
</pre><p>描述数据集。<code class="literal">describe()</code>功能提供项目分析。<code class="literal">BollingerBands</code>作为输入参数传递:</p><p>结果如下:</p><div><img src="img/image_06_100.jpg" alt="Step 3 - preparing variables to build datasets"/></div><p>
</p><p>Printing the summary of the <code class="literal">HighLowClose</code> data frame. The <code class="literal">summary()</code> function is a multipurpose function. <code class="literal">summary()</code> is a generic function, which provides a summary of the data related to the individual object or data frame. The <code class="literal">HighLowClose</code> data frame is passed as an R object to the <code class="literal">summary()</code> function:</p><pre class="programlisting">
<strong>    &gt; summary(HighLowClose)</strong>
</pre><p>构建上层乐队:</p><p>打印<code class="literal">Upper</code>数据框的摘要。<code class="literal">summary()</code>功能是多功能功能。<code class="literal">summary()</code>是一个通用函数，提供与单个对象或数据帧相关的数据汇总。<code class="literal">Upper</code>数据帧作为R对象传递给<code class="literal">summary()</code>函数:</p><div><img src="img/image_06_101.jpg" alt="Step 3 - preparing variables to build datasets"/></div><p>结果如下:</p><p>Exploring the internal structure of the <code class="literal">HighLowClose</code> data frame. The <code class="literal">str()</code> function displays the internal structure of the data frame. The <code class="literal">HighLowClose</code> is passed as an R object to the <code class="literal">str()</code> function:</p><pre class="programlisting">
<strong>    &gt; str(HighLowClose)</strong>
</pre><p>The result is as follows:</p><p>构建低频带:</p><div><img src="img/image_06_102.jpg" alt="Step 3 - preparing variables to build datasets"/></div><p>打印<code class="literal">Lower</code>数据帧的摘要。<code class="literal">summary()</code>功能是一个多功能功能。<code class="literal">summary()</code>是一个通用函数，它提供了与单个对象或数据框相关的数据摘要。下部数据帧作为R对象传递给<code class="literal">summary()</code>函数:</p><p>结果如下:</p><pre class="programlisting">
<strong>    &gt; HighLowClosets &lt;- data.frame(HighLowClose, row.names=DateAndTime) </strong>
</pre><p>Describing the dataset. The <code class="literal">describe()</code> function provides the item analysis. <code class="literal">HighLowClosets</code> is passed as an input argument:</p><pre class="programlisting">
<strong>    &gt; describe(HighLowClosets)</strong>
</pre><p>The result is as follows:</p><p>构建中间波段:</p><div><img src="img/image_06_103.jpg" alt="Step 3 - preparing variables to build datasets"/></div><p>打印<code class="literal">Middle</code>数据框的摘要。<code class="literal">summary()</code>功能是多功能功能。<code class="literal">summary()</code>是一个通用函数，提供与单个对象或数据帧相关的数据汇总。<code class="literal">Middle</code>数据帧作为R对象传递给<code class="literal">summary()</code>函数:</p><p>结果如下:</p><pre class="programlisting">
<strong>    &gt; HighLowClosexts &lt;- as.xts(HighLowClosets)</strong>
</pre><p>Calculating the Bollinger Bands. Bollinger Bands are range-bound indicators that calculate standard deviation from the moving average. Bollinger Bands operate under the logic that a currency pair's price is most likely to gravitate toward its average, and hence when it strays too far, such as two standard deviations away, it is due to retrace back to its moving average. The <code class="literal">BBands()</code> function is used to calculate Bollinger Bands. <code class="literal">HighLowClosexts</code> is passed as an object that is changed to a matrix, which contains high-low-close prices. <code class="literal">n=20</code> indicates the number of periods for moving average. SMA names the function to be called. <code class="literal">sd=2</code> indicates two standard deviations:</p><pre class="programlisting">
<strong>    &gt; BollingerBands &lt;- BBands(HighLowClosexts,n=20,SMA,sd=2)</strong>
</pre><p>Describing the dataset. The <code class="literal">describe()</code> function provides item analysis. <code class="literal">BollingerBands</code> is passed as an input argument:</p><pre class="programlisting">
<strong>    &gt; describe(BollingerBands)</strong>
</pre><p>计算百分比变化。<code class="literal">Delt()</code>函数用于计算给定系列从一个周期到另一个周期的百分比变化。<code class="literal">k=1</code>表示期间的变化。结果存储在<code class="literal">PercentageChngpctB</code>数据帧中:</p><p>描述数据集。<code class="literal">describe()</code>功能提供项目分析。<code class="literal">PercentageChngpctB</code>作为输入参数传递:</p><div><img src="img/image_06_104.jpg" alt="Step 3 - preparing variables to build datasets"/></div><p>结果如下:</p><p>Building the upper band:</p><pre class="programlisting">
<strong>    &gt; Upper &lt;- BollingerBands$up - HighLowClosexts$Close</strong>
</pre><p>Printing the summary of the <code class="literal">Upper</code> data frame. The <code class="literal">summary()</code> function is a multipurpose function. <code class="literal">summary()</code> is a generic function, which provides a summary of the data related to the individual object or data frame. The <code class="literal">Upper</code> data frame is passed as an R object to the <code class="literal">summary()</code> function:</p><pre class="programlisting">
<strong>    &gt; summary(Upper)</strong>
</pre><p>计算<code class="literal">Upper</code>数据帧的百分比变化。<code class="literal">k=1</code>表示期间的变化:</p><p>描述数据集。<code class="literal">describe()</code>功能提供项目分析。<code class="literal">PercentageChngUp</code>作为输入参数传递:</p><div><img src="img/image_06_105.jpg" alt="Step 3 - preparing variables to build datasets"/></div><p>结果如下:</p><p>Building the lower band:</p><pre class="programlisting">
<strong>    &gt; Lower &lt;- BollingerBands$dn - HighLowClosexts$Close</strong>
</pre><p>Printing the summary of the <code class="literal">Lower</code> data frame. The <code class="literal">summary()</code> function is a multipurpose function. <code class="literal">summary()</code> is a generic function, which provides a summary of the data related to the individual object or data frame. The Lower data frame is passed as an R object to the <code class="literal">summary()</code> function:</p><pre class="programlisting">
<strong>    &gt; summary(Upper)</strong>
</pre><p>计算<code class="literal">Lower</code>数据帧的百分比变化。<code class="literal">k=1</code>表示期间的变化:</p><p>描述数据集。<code class="literal">describe()</code>功能提供项目分析。<code class="literal">PercentageChngLow</code>作为输入参数传递:</p><div><img src="img/image_06_106.jpg" alt="Step 3 - preparing variables to build datasets"/></div><p>结果如下:</p><p>Building the middle band:</p><pre class="programlisting">
<strong>    &gt; Middle &lt;- BollingerBands$mavg - HighLowClosexts$Close</strong>
</pre><p>Printing the summary of the <code class="literal">Middle</code> data frame. The <code class="literal">summary()</code> function is a multipurpose function. <code class="literal">summary()</code> is a generic function which provides a summary of the data related to the individual object or data frame. The <code class="literal">Middle</code> data frame is passed as an R object to the <code class="literal">summary()</code> function:</p><pre class="programlisting">
<strong>    &gt; summary(Middle)</strong>
</pre><p>计算<code class="literal">Middle</code>数据帧的百分比变化。<code class="literal">k=1</code>表示期间的变化:</p><p>描述数据集。<code class="literal">describe()</code>功能提供项目分析。<code class="literal">PercentageChngMid</code>作为输入参数传递:</p><div><img src="img/image_06_107.jpg" alt="Step 3 - preparing variables to build datasets"/></div><p>结果如下:</p><p>Calculating the percentage change. The <code class="literal">Delt()</code> function is used to calculate the percentage change from one period to another of a given series. <code class="literal">k=1</code> indicates the change over the periods. The result is stored in the <code class="literal">PercentageChngpctB</code> data frame:</p><pre class="programlisting">
<strong>    &gt; PercentageChngpctB &lt;- Delt(BollingerBands$pctB,k=1)</strong>
</pre><p>Describing the dataset. The <code class="literal">describe()</code> function provides item analysis. <code class="literal">PercentageChngpctB</code> is passed as an input argument:</p><pre class="programlisting">
<strong>    &gt; describe(PercentageChngpctB)</strong>
</pre><p>计算<code class="literal">HighLowClosexts$Close</code>变量的百分比变化。<code class="literal">k=1</code>表示各时期的变化:</p><p><a id="ch06lvl3sec106"/>第4步-建立模型</p><div><img src="img/image_06_108.jpg" alt="Step 3 - preparing variables to build datasets"/></div><p>创建二元分类变量。<code class="literal">ifelse()</code>函数使用一个测试表达式来返回值，该值本身是一个向量，并且与测试表达式的长度相同。如果测试表达式的对应值是<code class="literal">TRUE</code>，则返回的向量具有来自<code class="literal">x</code>的元素，如果测试表达式的对应值是<code class="literal">FALSE</code>，则返回来自<code class="literal">y</code>的元素。</p><p>这里，<code class="literal">Returns&gt;0</code>是测试函数，要在逻辑模式下测试。<code class="literal">UP</code>和<code class="literal">DOWN</code>执行逻辑测试。然后将结果存储在<code class="literal">binaryClassification</code>数据帧中:</p><pre class="programlisting">
<strong>    &gt; PercentageChngUp &lt;- Delt(Upper,k=1)</strong>
</pre><p>探索价格变化的汇总。使用<code class="literal">summary()</code>功能。该函数提供一系列描述性统计数据，以生成<code class="literal">binaryClassification</code>数据帧的结果汇总:</p><pre class="programlisting">
<strong>    &gt; describe(PercentageChngUp)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_06_109.jpg" alt="Step 3 - preparing variables to build datasets"/></div><p>
</p><p>将班级向后移一位:</p><pre class="programlisting">
<strong>    &gt; PercentageChngLow &lt;- Delt(Lower, k=1)</strong>
</pre><p>结合了所有的特点。<code class="literal">data.frame()</code>函数用于根据一组紧密耦合的变量创建数据框。这些变量共享矩阵的属性。</p><pre class="programlisting">
<strong>    &gt; describe(PercentageChngLow)</strong>
</pre><p>作为参数传递给<code class="literal">data.frame()</code>的变量有<code class="literal">Upper</code>、<code class="literal">Lower</code>、<code class="literal">Middle</code>、<code class="literal">BollingerBands$pctB</code>、<code class="literal">PercentageChngpctB</code>、<code class="literal">PercentageChngUp</code>、<code class="literal">PercentageChngLow</code>和<code class="literal">PercentageChngMid</code>。结果存储在<code class="literal">FeaturesCombined</code>数据框中:</p><p>探索价格变化的汇总。使用<code class="literal">summary()</code>功能。该函数提供一系列描述性统计数据，以生成<code class="literal">FeaturesCombined</code>数据帧的结果汇总:</p><div><img src="img/image_06_110.jpg" alt="Step 3 - preparing variables to build datasets"/></div><p>结果如下:</p><p>Calculating the percentage change of the <code class="literal">Middle</code> data frame. <code class="literal">k=1</code> indicates the change over the periods:</p><pre class="programlisting">
<strong>    &gt; PercentageChngMid &lt;- Delt(Middle,k=1)</strong>
</pre><p>Describing the dataset. The <code class="literal">describe()</code> function provides item analysis. <code class="literal">PercentageChngMid</code> is passed as an input argument:</p><pre class="programlisting">
<strong>    &gt; describe(PercentageChngMid)</strong>
</pre><p>匹配类别:</p><p>组合<code class="literal">FeaturesShifted</code>和<code class="literal">ClassShifted</code>数据帧。作为参数传递给<code class="literal">data.frame()</code>的变量是<code class="literal">FeaturesShifted</code>和<code class="literal">ClassShifted</code>。然后将结果存储在<code class="literal">FeaturesClassData</code>数据帧中:</p><div><img src="img/image_06_111.jpg" alt="Step 3 - preparing variables to build datasets"/></div><p>探索价格变化的汇总。使用<code class="literal">summary()</code>功能。该函数提供一系列描述性统计数据，以生成<code class="literal">FeaturesClassData</code>数据帧的结果汇总:</p><p>结果如下:</p><pre class="programlisting">
<strong>    &gt; Returns &lt;- Delt(HighLowClosexts$Close, k=1)</strong>
</pre></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec106"/>Step 4 - building the model</h3></div></div></div><p>Creating a binary classification variable. The <code class="literal">ifelse()</code> function uses a test expression to return the value, which is itself a vector, and is of the same length as the test expression. The vector returned has an element from <code class="literal">x</code> if the corresponding value of the test expression is <code class="literal">TRUE</code>, or from <code class="literal">y</code> if the corresponding value of the test expression is <code class="literal">FALSE</code>.</p><p>被删除的计算指标:</p><pre class="programlisting">
<strong>    &gt; binaryClassification &lt;- ifelse(Returns&gt;0,"Up","Down") </strong>
</pre><p>命名列。<code class="literal">c()</code>函数用于将参数组合成向量:</p><pre class="programlisting">
<strong>    &gt; summary(binaryClassification)</strong>
</pre><p>探索<code class="literal">FinalModelData</code>数据帧的内部结构。<code class="literal">str()</code>功能显示数据帧的内部结构。<code class="literal">FinalModelData</code>作为R对象传递给<code class="literal">str()</code>函数:</p><p>结果如下:</p><div><img src="img/image_06_112.jpg" alt="Step 4 - building the model"/></div><p>
</p><p>Shifting class back one:</p><pre class="programlisting">
<strong>    &gt; ClassShifted &lt;- binaryClassification[-1]</strong>
</pre><p>设置初始随机变量:</p><p>使用类(第9列)评估特征(第1至9列)，以找到每棵树的最佳特征数量。<code class="literal">FinalModelData[,-9]</code>表示预测变量的数据框架，<code class="literal">FinalModelData[,9]</code>表示响应变量的数据框架。<code class="literal">ntreeTry=100</code>表示在调整步骤中使用的树的数量。<code class="literal">stepFactor=1.5</code>表示每次迭代；<code class="literal">mtry</code>因该值而增大(或缩小)，而<code class="literal">improve=0.01</code>意味着袋外误差的(相对)改善必须达到这个程度，搜索才能继续。<code class="literal">trace=TRUE</code>表示是否打印搜索的进度。<code class="literal">dobest=FALSE</code>表示是否使用找到的最优<code class="literal"> mtry</code>运行森林:</p><pre class="programlisting">
<strong>    &gt; FeaturesCombined &lt;- data.frame(Upper, Lower, Middle, BollingerBands$pctB, PercentageChngpctB, PercentageChngUp, PercentageChngLow, PercentageChngMid)</strong>
</pre><p>使用所有特征来预测类别，每个树有两个特征。使用<code class="literal">randomForest()</code>功能。<code class="literal">data=FinalModelData</code>表示模型中包含变量的数据框。<code class="literal">mtry=2</code>表示每次分割时随机抽样作为候选变量的变量数量。<code class="literal">ntree=2000</code>表示要种植的树木数量。<code class="literal">keep.forest=TRUE</code>表示森林将保留在输出对象中。<code class="literal">importance=TRUE</code>表示待评估预测因子的重要性:</p><pre class="programlisting">
<strong>    &gt; summary(FeaturesCombined)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_06_113.jpg" alt="Step 4 - building the model"/></div><p>
</p><p>绘制随机森林:</p><pre class="programlisting">
<strong>    &gt; FeaturesShifted &lt;- FeaturesCombined[-5257,]</strong>
</pre><p>结果如下:</p><pre class="programlisting">
<strong>    &gt; FeaturesClassData &lt;- data.frame(FeaturesShifted, ClassShifted)</strong>
</pre><p>Exploring the summary of change in prices. The <code class="literal">summary()</code> function is used. The function provides a range of descriptive statistics to produce result summaries of the <code class="literal">FeaturesClassData</code> data frame:</p><pre class="programlisting">
<strong>    &gt; summary(FeaturesClassData)</strong>
</pre><p>The result is as follows:</p><p><a id="ch06lvl1sec35"/>支持向量机-货币交易策略</p><div><img src="img/image_06_114.jpg" alt="Step 4 - building the model"/></div><p>外汇市场是一个国际交易市场，每个国家的货币都可以自由买卖。仅由市场参与者决定的一种货币的价格是由供求关系决定的。交易是通过单个合约进行的。标准合约规模(也称为批量)通常为100，000个单位。这意味着，对于所获得的每个标准合约，控制权是100，000单位的基础货币。对于这个合约规模，每个点(最小价格增量)值10美元。根据交易者的交易策略，头寸可以维持很短时间，也可以维持很长时间，甚至几年。有几个工具可以让交易者理解市场并做出决定，这些工具基本上归入基本面或技术面分析。基本面分析考虑到政治和经济信息的不断交流。技术分析基本上是基于价格、时间和交易量——一种货币的最低价和最高价、时间段、交易次数等等。技术分析也假设了市场的重复性，它很可能会像过去一样在未来重复。它分析过去的报价，并根据统计和数学计算预测未来的价格。</p><p><a id="ch06lvl2sec42"/>准备就绪</p><pre class="programlisting">
<strong>    &gt; FinalModelData &lt;- FeaturesClassData[-c(1:20),]</strong>
</pre><p>为了执行支持向量机，我们将使用从美元和英镑数据集收集的数据集。</p><pre class="programlisting">
<strong>    &gt; colnames(FinalModelData) &lt;- c("pctB","LowDiff","UpDiff","MidDiff","PercentageChngpctB","PercentageChngUp","PercentageChngLow","PercentageChngMid","binaryClassification")</strong>
</pre><p><a id="ch06lvl3sec107"/>步骤1 -收集和描述数据</p><pre class="programlisting">
<strong>    &gt; str(FinalModelData)</strong>
</pre><p>将使用名为<code class="literal">PoundDollar.csv</code>的数据集。数据集采用标准格式。有5，257行数据和6个变量。数字变量如下:</p><p><code class="literal">Date</code></p><div><img src="img/image_06_115.jpg" alt="Step 4 - building the model"/></div><p><code class="literal">Open</code></p><p><code class="literal">High</code></p><pre class="programlisting">
<strong>    &gt; set.seed(1)</strong>
</pre><p><code class="literal">Low</code></p><pre class="programlisting">
<strong>    &gt; FeatureNumber &lt;- tuneRF(FinalModelData[,-9], FinalModelData[,9], ntreeTry=100, stepFactor=1.5, improve=0.01, trace=TRUE, plot=TRUE, dobest=FALSE)</strong>
</pre><p><code class="literal">Close</code></p><pre class="programlisting">
<strong>    &gt; RandomForest &lt;- randomForest(binaryClassification~., data=FinalModelData, mtry=2,  ntree=2000, keep.forest=TRUE, importance=TRUE)</strong>
</pre><p><code class="literal">Volume</code></p><p><a id="ch06lvl2sec43"/>怎么做...</p><div><img src="img/image_06_116.jpg" alt="Step 4 - building the model"/></div><p>让我们进入细节。</p><p><a id="ch06lvl3sec108"/>第2步-探索数据</p><pre class="programlisting">
<strong>    &gt; varImpPlot(RandomForest, main = 'Random Forest: Measurement of Importance of Each Feature',pch=16,col='blue' )</strong>
</pre><p>作为要执行的第一步，需要加载以下软件包:</p><p><a id="note18"/>注意</p><div><img src="img/image_06_117.jpg" alt="Step 4 - building the model"/></div><p>版本信息:此页面的代码在R版本3.3.0中进行了测试(2016-05-03)。</p></div></div></div>





<title>Support vector machine - currency trading strategy</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title">需要安装以下每个库:</h1></div></div></div><p>让我们探索数据，了解变量之间的关系。我们将从导入名为<code class="literal">PoundDollar.csv</code>的CSV数据文件开始。我们将把数据保存到<code class="literal">PoundDollar</code>数据框中:</p><div><div><div><div><h2 class="title">打印<code class="literal">PoundDollar</code>数据帧。<code class="literal">head()</code>函数返回<code class="literal">PoundDollar</code>数据帧的第一部分。<code class="literal">PoundDollar</code>数据帧作为输入参数传递:</h2></div></div></div><p>结果如下:</p><div><div><div><div><h3 class="title">探索<code class="literal">PoundDollar</code>数据帧的内部结构。<code class="literal">str()</code>功能显示数据帧的内部结构。<code class="literal">PoundDollar</code>作为R对象传递给<code class="literal">str()</code>函数:</h3></div></div></div><p>结果如下:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Date</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Open</code></li><li class="listitem" style="list-style-type: disc"><a id="ch06lvl3sec109"/>步骤3 -计算指标</li><li class="listitem" style="list-style-type: disc">计算相对强度指数。它是最近价格上升运动与绝对价格运动的比率。<code class="literal">RSI()</code>函数用于计算相对强度指数。<code class="literal">PoundDollar</code>数据框用作价格序列。<code class="literal">n = 3</code>代表移动平均线的周期数。然后将结果存储在<code class="literal">relativeStrengthIndex3</code>数据帧中:</li><li class="listitem" style="list-style-type: disc">探索价格变化的汇总。使用<code class="literal">summary()</code>功能。该函数提供了一系列描述性统计数据，以生成<code class="literal">relativeStrengthIndex3</code>数据帧的结果汇总:</li><li class="listitem" style="list-style-type: disc">结果如下:</li></ul></div></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec43"/>How to do it...</h2></div></div></div><p>Let's get into the details.</p><div><div><div><div><h3 class="title">计算<code class="literal">PoundDollar</code>系列的<strong>移动平均线</strong> ( <strong> MA </strong>)。<code class="literal">SMA</code>计算过去一组观察值序列的算术平均值。<code class="literal">n=50</code>表示平均的周期数:</h3></div></div></div><p>打印<code class="literal">SeriesMeanAvg50</code>数据帧的摘要。<code class="literal">summary()</code>功能是多功能功能。<code class="literal">summary()</code>是一个通用函数，提供与单个对象或数据框相关的数据汇总。<code class="literal">SeriesMeanAvg50</code>数据帧作为R对象传递给<code class="literal">summary()</code>函数:</p><pre class="programlisting">
<strong>&gt; install.packages("quantmod")
&gt; install.packages("e1071")
&gt; install.packages("Hmisc")
&gt; install.packages("ggplot2")</strong>
</pre><div><div><h3 class="title">结果如下:</h3><p>Version info: Code for this page was tested in R version 3.3.0 (2016-05-03).</p></div></div><p>Each of the following libraries needs to be installed:</p><pre class="programlisting">
<strong>&gt; library("quantmod")
&gt; library("e1071")
&gt; library("Hmisc")
&gt; install.packages("ggplot2")</strong>
</pre><p>描述数据集。<code class="literal">describe()</code>功能提供项目分析。<code class="literal">SeriesMeanAvg50</code>作为输入参数传递:</p><pre class="programlisting">
<strong>    &gt; PoundDollar &lt;- read.csv("d:/PoundDollar.csv")</strong>
</pre><p>结果如下:</p><pre class="programlisting">
<strong>    &gt; head(PoundDollar)</strong>
</pre><p>The result is as follows:</p><p>
</p><div><img src="img/image_06_118.jpg" alt="Step 2 - exploring the data"/></div><p>衡量趋势。找出开盘价和50期简单移动平均线之间的差异:</p><p>打印<code class="literal">SeriesMeanAvg50</code>数据帧的摘要。<code class="literal">Trend</code>数据帧作为R对象传递给<code class="literal">summary()</code>函数:</p><pre class="programlisting">
<strong>    &gt; str(PoundDollar)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_06_119.jpg" alt="Step 2 - exploring the data"/></div><p>
</p></div><div><div><div><div><h3 class="title">计算收盘价和开盘价之间的差价。结果存储在数据帧<code class="literal">PriceDiff</code>中:</h3></div></div></div><p>打印<code class="literal">PriceDiff</code>数据帧的摘要。<code class="literal">Trend</code>数据帧作为R对象传递给<code class="literal">summary()</code>函数:</p><pre class="programlisting">
<strong>    &gt; relativeStrengthIndex3 &lt;- RSI(Op(PoundDollar), n= 3)</strong>
</pre><p>结果如下:</p><pre class="programlisting">
<strong>    &gt; summary(relativeStrengthIndex3)</strong>
</pre><p>The result is as follows:</p><p>
</p><div><img src="img/image_06_120.jpg" alt="Step 3 - calculating the indicators"/></div><p><a id="ch06lvl3sec110"/>步骤4 -准备变量以构建数据集</p><p>创建二元分类变量。<code class="literal">ifelse()</code>函数使用一个测试表达式返回值，该值本身是一个向量，与测试表达式的长度相同。如果测试表达式的对应值是<code class="literal">TRUE</code>，则返回的向量具有来自<code class="literal">x</code>的元素，如果测试表达式的对应值是<code class="literal">FALSE</code>，则返回来自<code class="literal">y</code>的元素。</p><pre class="programlisting">
<strong>    &gt; SeriesMeanAvg50 &lt;- SMA(Op(PoundDollar), n=50)</strong>
</pre><p>这里，<code class="literal">PriceChange&gt;0</code>是测试函数，要在逻辑模式下测试。<code class="literal">UP</code>和<code class="literal">DOWN</code>执行逻辑测试。然后将结果存储在<code class="literal">binaryClassification</code>数据帧中:</p><pre class="programlisting">
<strong>    &gt; summary(SeriesMeanAvg50)</strong>
</pre><p>打印<code class="literal">binaryClassification</code>数据帧的摘要。<code class="literal">Trend</code>数据帧作为R对象传递给<code class="literal">summary()</code>函数:</p><p>结果如下:</p><div><img src="img/image_06_121.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p><p>Describing the dataset. The <code class="literal">describe()</code> function provides the item analysis. <code class="literal">SeriesMeanAvg50</code> is passed as an input argument:</p><pre class="programlisting">
<strong>    &gt; describe(SeriesMeanAvg50)</strong>
</pre><p>组合相关的<code class="literal">StrengthIndex3</code>、<code class="literal">Trend</code>和<code class="literal">binaryClassification</code>数据帧。作为参数传递给<code class="literal">data.frame()</code>的变量有<code class="literal">relativeStrengthIndex3</code>、<code class="literal">Trend</code>和<code class="literal">binaryClassification</code>。然后将结果存储在<code class="literal">DataSet</code>数据帧中:</p><p>打印<code class="literal">DataSet</code>数据帧的摘要。<code class="literal">Trend</code>数据帧作为R对象传递给<code class="literal">summary()</code>函数:</p><div><img src="img/image_06_122.jpg" alt="Step 3 - calculating the indicators"/></div><p>结果如下:</p><p>Measuring the trend. Finding the difference between opening price and the 50-period simple moving average:</p><pre class="programlisting">
<strong>    &gt; Trend &lt;- Op(PoundDollar) - SeriesMeanAvg50</strong>
</pre><p>Printing the summary of the <code class="literal">SeriesMeanAvg50</code> data frame. The <code class="literal">Trend</code> data frame is passed as an R object to the <code class="literal">summary()</code> function:</p><pre class="programlisting">
<strong>    &gt; summary(Trend)</strong>
</pre><p>探索<code class="literal">DataSet</code>数据帧的内部结构。<code class="literal">str()</code>功能显示数据帧的内部结构。<code class="literal">DataSet</code>作为R对象传递给<code class="literal">str()</code>函数:</p><p>结果如下:</p><div><img src="img/image_06_123.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p><p>Calculating the price difference between closing and opening prices. The result is stored in the data frame <code class="literal">PriceDiff</code>:</p><pre class="programlisting">
<strong>    &gt; PriceDiff &lt;- Cl(PoundDollar) - Op(PoundDollar)</strong>
</pre><p>计算指标、创建数据集和移除点:</p><pre class="programlisting">
<strong>    &gt; summary(PriceDiff)</strong>
</pre><p>探索<code class="literal">DataSet</code>数据框的尺寸。<code class="literal">dim()</code>函数返回<code class="literal">DataSet</code>框架的尺寸。<code class="literal">DataSet</code>数据帧作为输入参数传递。结果清楚地表明有5，208行数据和3列:</p><p>结果如下:</p><div><img src="img/image_06_124.jpg" alt="Step 3 - calculating the indicators"/></div><p>
</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec110"/>Step 4 - preparing variables to build datasets</h3></div></div></div><p>分离训练数据集:</p><p>探索<code class="literal">TrainingDataSet</code>数据帧的尺寸。<code class="literal">dim()</code>函数返回<code class="literal">TrainingDataSet</code>框架的尺寸。<code class="literal">TrainingDataSet</code>数据帧作为输入参数传递。结果清楚地表明有4，528行数据和3列:</p><pre class="programlisting">
<strong>    &gt; binaryClassification &lt;- ifelse(PriceDiff&gt;0,"UP","DOWN")</strong>
</pre><p>结果如下:</p><pre class="programlisting">
<strong>    &gt; summary(binaryClassification)</strong>
</pre><p>The result is as follows:</p><p>
</p><div><img src="img/image_06_125.jpg" alt="Step 4 - preparing variables to build datasets"/></div><p>打印<code class="literal">TrainingDataSet</code>数据帧的摘要。<code class="literal">TrainingDataSet</code>数据帧作为R对象传递给<code class="literal">summary()</code>函数:</p><p>结果如下:</p><pre class="programlisting">
<strong>    &gt; DataSet &lt;- data.frame(relativeStrengthIndex3, Trend, binaryClassification)</strong>
</pre><p>Printing the summary of the <code class="literal">DataSet</code> data frame. The <code class="literal">Trend</code> data frame is passed as an R object to the <code class="literal">summary()</code> function:</p><pre class="programlisting">
<strong>    &gt; summary(DataSet)</strong>
</pre><p>The result is as follows:</p><p>分离测试数据集:</p><div><img src="img/image_06_126.jpg" alt="Step 4 - preparing variables to build datasets"/></div><p>探索<code class="literal">TestDataSet</code>数据框的维度。<code class="literal">dim()</code>函数返回<code class="literal">TestDataSet</code>帧的尺寸。<code class="literal">TestDataSet</code>数据帧作为输入参数传递。结果清楚地表明有1，510行数据和3列:</p><p>Exploring the internal structure of the <code class="literal">DataSet</code> data frame. The <code class="literal">str()</code> function displays the internal structure of the data frame. The <code class="literal">DataSet</code> is passed as an R object to the <code class="literal">str()</code> function:</p><pre class="programlisting">
<strong>    &gt; str(DataSet)</strong>
</pre><p>The result is as follows:</p><p>打印<code class="literal">TestDataSet</code>数据帧的摘要。<code class="literal">TestDataSet</code>数据帧作为R对象传递给<code class="literal">summary()</code>函数:</p><div><img src="img/image_06_127.jpg" alt="Step 4 - preparing variables to build datasets"/></div><p>结果如下:</p><p>Calculating the indicators, creating a dataset, and removing the points:</p><pre class="programlisting">
<strong>    &gt; DataSet &lt;- DataSet[-c(1:49),]</strong>
</pre><p>Exploring the dimensions of the <code class="literal">DataSet</code> data frame. The <code class="literal">dim()</code> function returns the dimensions of the <code class="literal">DataSet</code> frame. The <code class="literal">DataSet</code> data frame is passed as an input parameter. The result clearly states that there are 5,208 rows of data and 3 columns:</p><pre class="programlisting">
<strong>    &gt; dim(DataSet) </strong>
</pre><p><a id="ch06lvl3sec111"/>第5步-建立模型</p><p>使用<code class="literal">svm()</code>函数构建支持向量机。<code class="literal">binaryClassification~relativeStrengthIndex3+Trend</code>用作公式。<code class="literal">data=TrainingDataSet</code>用作包含模型变量的数据框。<code class="literal">kernel="radial"</code>表示径向基核函数用于训练和预测。<code class="literal">cost=1</code>表示违反约束的成本。<code class="literal">gamma=1/2</code>表示除线性外的所有核函数所需的参数:</p><div><img src="img/image_06_128.jpg" alt="Step 4 - preparing variables to build datasets"/></div><p>打印<code class="literal">SVM</code>数据帧的摘要。<code class="literal">SVM</code>数据帧作为R对象传递给<code class="literal">summary()</code>函数:</p><p>结果如下:</p><pre class="programlisting">
<strong>    &gt; TrainingDataSet &lt;- DataSet[1:4528,]</strong>
</pre><p>Exploring the dimensions of the <code class="literal">TrainingDataSet</code> data frame. The <code class="literal">dim()</code> function returns the dimensions of the <code class="literal">TrainingDataSet</code> frame. The <code class="literal">TrainingDataSet</code> data frame is passed as an input parameter. The result clearly states that there are 4,528 rows of data and 3 columns:</p><pre class="programlisting">
<strong>    &gt; dim(TrainingDataSet)</strong>
</pre><p>The result is as follows:</p><p>为了预测基于模型对象的值，我们将使用<code class="literal">predict()</code>函数。<code class="literal">SVM</code>作为宾语传递。<code class="literal">TrainingDataSet</code>数据对象作为一个对象被传递，在其中寻找预测变量:</p><div><img src="img/image_06_129.jpg" alt="Step 4 - preparing variables to build datasets"/></div><p>打印<code class="literal">TrainingPredictions</code>数据帧的摘要。<code class="literal">SVM</code>数据帧作为R对象传递给<code class="literal">summary()</code>函数:</p><p>结果如下:</p><pre class="programlisting">
<strong>    &gt; summary(TrainingDataSet)</strong>
</pre><p>The result is as follows:</p><p>
</p><div><img src="img/image_06_130.jpg" alt="Step 4 - preparing variables to build datasets"/></div><p>描述数据集。<code class="literal">describe()</code>功能提供项目分析。<code class="literal">TrainingPredictions</code>作为输入参数传递:</p><p>结果如下:</p><pre class="programlisting">
<strong>    &gt; TestDataSet &lt;- DataSet[4529:6038,]</strong>
</pre><p>Exploring the dimensions of the <code class="literal">TestDataSet</code> data frame. The <code class="literal">dim()</code> function returns the dimensions of the <code class="literal">TestDataSet</code> frame. The <code class="literal">TestDataSet</code> data frame is passed as an input parameter. The result clearly states that there are 1,510 rows of data and 3 columns:</p><pre class="programlisting">
<strong>    &gt; dim(TestDataSet)</strong>
</pre><p>
</p><div><img src="img/image_06_131.jpg" alt="Step 4 - preparing variables to build datasets"/></div><p>组合<code class="literal">TrainingDataSet</code>和<code class="literal">TrainingPredictions</code>数据帧。作为参数传递给<code class="literal">data.frame()</code>的变量是<code class="literal">TrainingDataSet</code>和<code class="literal">TrainingPredictions</code>。结果存储在<code class="literal">TrainingDatadata</code>框中:</p><p>打印<code class="literal">TrainingData</code>数据帧的摘要。<code class="literal">TrainingData</code>数据帧作为R对象传递给<code class="literal">summary()</code>函数:</p><pre class="programlisting">
<strong>    &gt; summary(TestDataSet)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_06_132.jpg" alt="Step 4 - preparing variables to build datasets"/></div><p>
</p></div><div><div><div><div><h3 class="title">打印<code class="literal">TrainingData</code>:</h3></div></div></div><p>结果如下:</p><pre class="programlisting">
<strong>    &gt; SVM &lt;- svm(binaryClassification~relativeStrengthIndex3+Trend, data=TrainingDataSet, kernel="radial", cost=1, gamma=1/2)</strong>
</pre><p>Printing the summary of the <code class="literal">SVM</code> data frame. The <code class="literal">SVM</code> data frame is passed as an R object to the <code class="literal">summary()</code> function:</p><pre class="programlisting">
<strong>    &gt; summary(SVM)</strong>
</pre><p>The result is as follows:</p><p><a id="ch06lvl1sec36"/>随机梯度下降——成人收入</p><div><img src="img/image_06_133.jpg" alt="Step 5 - building the model"/></div><p><strong>随机梯度下降</strong>也称为<strong>增量</strong>梯度下降，是梯度下降优化方法的随机近似，用于最小化目标函数，写为可微函数的和。它试图通过迭代找到最小值或最大值。在随机梯度下降中，<em> Q(w) </em>的真实梯度由单个示例中的梯度近似:</p><p>In order to predict the value based on the model object, we will use the <code class="literal">predict()</code> function. <code class="literal">SVM</code> is passed as an object. The <code class="literal">TrainingDataSet</code> data object is passed as an object in which to look for variables with which to predict:</p><pre class="programlisting">
<strong>    &gt; TrainingPredictions &lt;- predict(SVM, TrainingDataSet, type="class")</strong>
</pre><p>Printing the summary of the <code class="literal">TrainingPredictions</code> data frame. The <code class="literal">SVM</code> data frame is passed as an R object to the <code class="literal">summary()</code> function:</p><pre class="programlisting">
<strong>    &gt; summary(TrainingPredictions)</strong>
</pre><p>当算法扫过训练集时，它对每个训练示例执行上述更新。可以对训练集进行多次遍历，直到算法收敛。如果做到了这一点，就可以在每次传递时打乱数据以防止循环。典型的实现可以使用自适应学习速率，以便算法收敛。</p><p>做好准备</p><div><img src="img/image_06_134.jpg" alt="Step 5 - building the model"/></div><p>为了执行随机梯度下降，我们将使用从人口普查数据中收集的数据集来预测收入。</p><p><a id="ch06lvl3sec112"/>步骤1 -收集和描述数据</p><pre class="programlisting">
<strong>    &gt; describe(TrainingPredictions)</strong>
</pre><p>将使用名为<code class="literal">adult.txt</code>的数据集。数据集采用标准格式。有32，561行数据和15个变量。数字变量如下:</p><p><code class="literal">age</code></p><div><img src="img/image_06_135.jpg" alt="Step 5 - building the model"/></div><p><code class="literal">fnlwgt</code></p><p><code class="literal">education-num</code></p><pre class="programlisting">
<strong>    &gt; TrainingData &lt;- data.frame (TrainingDataSet, TrainingPredictions)</strong>
</pre><p><code class="literal">capital-gain</code></p><pre class="programlisting">
<strong>    &gt; summary(TrainingData)</strong>
</pre><p><code class="literal">capital-loss</code></p><p><code class="literal">hours-per-week</code></p><div><img src="img/image_06_136.jpg" alt="Step 5 - building the model"/></div><p>非数字变量如下:</p><p><code class="literal">workclass</code></p><pre class="programlisting">
<strong>    &gt; ggplot(TrainingData,aes(x=Trend,y=relativeStrengthIndex3))    +stat_density2d(geom="contour",aes(color=TrainingPredictions))    +labs(,x="Open - SMA50",y="RSI3",color="Training Predictions")</strong>
</pre><p><code class="literal">education</code></p><p><code class="literal">marital-status</code></p><div><img src="img/image_06_137.jpg" alt="Step 5 - building the model"/></div><p><code class="literal">occupation</code></p></div></div></div>





<title>Stochastic gradient descent - adult income</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><code class="literal">relationship</code></h1></div></div></div><p><code class="literal">race</code></p><p><code class="literal">sex</code></p><div><img src="img/B04714_06_new.jpg" alt="Stochastic gradient descent - adult income"/></div><p><code class="literal">native-country</code></p><p><code class="literal">incomerange</code></p><div><div><div><div><h2 class="title">如何去做...</h2></div></div></div><p>让我们进入细节。</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec113"/>第2步-探索数据</h3></div></div></div><p>需要安装以下每个库:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a id="note19"/>注意</li><li class="listitem" style="list-style-type: disc">版本信息:此页面的代码在R版本3.3.0中进行了测试(2016-05-03)。</li><li class="listitem" style="list-style-type: disc">让我们探索数据，了解变量之间的关系。我们将从导入名为<code class="literal">adult.txt</code>的TXT数据文件开始。我们将把数据保存到标签数据框:</li><li class="listitem" style="list-style-type: disc">探索<code class="literal">allData</code>数据帧的内部结构。<code class="literal">str()</code>功能显示数据帧的内部结构。<code class="literal">allData</code>作为R对象传递给<code class="literal">str()</code>函数:</li><li class="listitem" style="list-style-type: disc">结果如下:</li><li class="listitem" style="list-style-type: disc"><code class="literal">hours-per-week</code></li></ul></div><p>The non-numeric variables are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a id="ch06lvl3sec114"/>步骤3 -准备数据</li><li class="listitem" style="list-style-type: disc">从主文件中抓取标签。<code class="literal">as.factor()</code>函数用于将<code class="literal">allData[,15]</code>矢量编码为一个因子。这是为了确保格式兼容性。然后将结果存储在<code class="literal">labels</code>数据帧中:</li><li class="listitem" style="list-style-type: disc">移除标注后获取数据的所有特征。结果存储在<code class="literal">allFeatures</code>数据帧中:</li><li class="listitem" style="list-style-type: disc">打印<code class="literal">allFeatures</code>数据帧。<code class="literal">head()</code>函数返回<code class="literal">allFeatures</code>数据帧的第一部分。<code class="literal">allFeatures</code>数据帧作为输入参数传递:</li><li class="listitem" style="list-style-type: disc">结果如下:</li><li class="listitem" style="list-style-type: disc"><code class="literal">race</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">sex</code></li><li class="listitem" style="list-style-type: disc">标准化特征。平均值和标度被转换成<code class="literal">z</code>分数，以便<code class="literal">variance = 1</code>。<code class="literal">scale()</code>函数的默认方法将数值矩阵的列居中和/或缩放。<code class="literal">continuousFeatures</code>是数值矩阵。然后将结果存储在<code class="literal">continuousFeatures</code>数据帧中:</li><li class="listitem" style="list-style-type: disc">打印<code class="literal">continuousFeatures</code>数据帧。<code class="literal">head()</code>函数返回<code class="literal">continuousFeatures</code>数据帧的第一部分。<code class="literal">continuousFeatures</code>数据帧作为输入参数传递:</li></ul></div></div></div><div><div><div><div><h2 class="title">结果如下:</h2></div></div></div><p>Let's get into the details.</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec113"/>Step 2 - exploring the data</h3></div></div></div><p>将标签转换成<code class="literal">1</code>或<code class="literal">-1</code>。<code class="literal">rep()</code>功能用于复制数值。然后将结果存储在<code class="literal">labels.n</code>数据帧中:</p><pre class="programlisting">
<strong>&gt; library("klar")
&gt; library("caret")
&gt; library ("stringr")</strong>
</pre><div><div><h3 class="title">分离训练数据集。<code class="literal">createDataPartition()</code>函数创建一组训练数据分区。<code class="literal">y=labels</code>表示结果的向量。<code class="literal">p=.8</code>表示80%的数据用于训练数据集:</h3><p>探索<code class="literal">trainingData</code>数据框的尺寸。<code class="literal">dim()</code>函数返回<code class="literal">trainingData</code>框架的尺寸。<code class="literal">trainingData</code>数据帧作为输入参数传递。结果清楚地表明有26，049行数据和一个单独的列:</p></div></div><p>结果如下:</p><pre class="programlisting">
<strong>    &gt; labels &lt;- read.csv("d:/adult.txt")</strong>
</pre><p>Exploring the internal structure of the <code class="literal">allData</code> data frame. The <code class="literal">str()</code> function displays the internal structure of the data frame. <code class="literal">allData</code> is passed as an R object to the <code class="literal">str()</code> function:</p><pre class="programlisting">
<strong>    &gt; str(allData)</strong>
</pre><p>The result is as follows:</p><p>创建<code class="literal">trainingData</code>数据框的训练特征和训练标签:</p><div><img src="img/image_06_138.jpg" alt="Step 2 - exploring the data"/></div><p>找出剩余20%的数据进行测试和验证:</p></div><div><div><div><div><h3 class="title">创建<code class="literal">trainingData</code>数据帧的测试特征和测试标签。在这20%的数据中，50%的数据用于测试目的，而剩下的50%用于验证目的。</h3></div></div></div><p><code class="literal">createDataPartition()</code>函数创建一组训练数据分区。<code class="literal">y= remainingLabels</code>表示结果的向量。<code class="literal">p=.5</code>表示50%的数据用于训练数据集。结果存储在<code class="literal">testingData</code>数据框中:</p><pre class="programlisting">
<strong>    &gt; labels &lt;- as.factor(allData[,15])</strong>
</pre><p>创建<code class="literal">testingData</code>数据帧的验证特征和测试标签:</p><pre class="programlisting">
<strong>    &gt; allFeatures &lt;- allData[,-c(15)]</strong>
</pre><p>定义所需的精度测量:</p><pre class="programlisting">
<strong>    &gt; head(allFeatures)</strong>
</pre><p><a id="ch06lvl3sec115"/>第4步-建立模型</p><p>设置初始参数:</p><div><img src="img/image_06_139.jpg" alt="Step 3 - preparing the data"/></div><p>合并一组参数。结果存储在<code class="literal">lambda_vals</code>数据帧中:</p><p>探索<code class="literal">lambda_vals</code>数据帧的内部结构。<code class="literal">str()</code>功能显示数据帧的内部结构。<code class="literal">lambda_vals</code>作为R对象传递给<code class="literal">str()</code>函数:</p><pre class="programlisting">
<strong>    &gt; continuousFeatures &lt;- scale(continuousFeatures)</strong>
</pre><p>结果如下:</p><pre class="programlisting">
<strong>    &gt; head(continuousFeatures)</strong>
</pre><p>The result is as follows:</p><p>
</p><div><img src="img/image_06_140.jpg" alt="Step 3 - preparing the data"/></div><p>根据一组给定的值为每个时期创建一个矩阵。使用<code class="literal">matrix()</code>功能。<code class="literal">nrow = (numStepsPerEpoch/nStepsPerPlot)*numEpochs+1</code>表示矩阵的行数，而<code class="literal">ncol = length(lambda_vals)</code>表示矩阵的列数:</p><p>根据给定的一组值创建验证集的准确性矩阵。使用<code class="literal">matrix()</code>功能。<code class="literal">nrow = (numStepsPerEpoch/nStepsPerPlot)*numEpochs+1</code>表示矩阵的行数，而<code class="literal">ncol = length(lambda_vals)</code>表示矩阵的列数:</p><pre class="programlisting">
<strong>    &gt; labels.n = rep(0,length(labels))     
&gt; labels.n[labels==" &lt;=50K"] = -1     
&gt; labels.n[labels==" &gt;50K"] = 1     
&gt; labels = labels.n     
&gt; rm(labels.n)</strong>
</pre><p>设置分类器模型:</p><pre class="programlisting">
<strong>    &gt; trainingData &lt;- createDataPartition(y=labels, p=.8, list=FALSE)</strong>
</pre><p><code class="literal">#createDataPartition()</code>函数创建一组训练数据分区。<code class="literal">y= trainingLabels</code>表示结果的向量。<code class="literal">p = (1 - evalidationSetSize/length(trainingLabels))</code> %的数据用于训练数据集。然后将结果存储在<code class="literal">etrainingData</code>数据帧中:</p><pre class="programlisting">
<strong>    &gt; dim(trainingData)</strong>
</pre><p>记录准确性。<code class="literal">getAccuracy()</code>被称为:</p><p>计算模型的精确度。如前所述，使用<code class="literal">getAccuracy()</code>:</p><div><img src="img/image_06_141.jpg" alt="Step 3 - preparing the data"/></div><p><a id="ch06lvl3sec116"/>第5步-绘制模型</p><p>在训练期间绘制模型的精确度。<code class="literal">c()</code>函数用于将参数组合成向量:</p><pre class="programlisting">
<strong>    &gt; trainingFeatures &lt;- continuousFeatures[trainingData,]     
&gt; trainingLabels &lt;- labels[trainingData]</strong>
</pre><p>设置图表中要使用的向量:</p><pre class="programlisting">
<strong>    &gt; remainingLabels &lt;- labels[-trainingData]     
&gt; remainingFeatures &lt;- continuousFeatures[-trainingData,]</strong>
</pre><p>创建一个通用向量。调用<code class="literal">list()</code>，它连接<code class="literal">accMat</code>和<code class="literal">accMatv</code>数据帧:</p><p>绘制图表:</p><pre class="programlisting">
<strong>    &gt; testingData &lt;- createDataPartition(y=remainingLabels, p=.5, list=FALSE)     
&gt; testingLabels &lt;- remainingLabels[testingData]     
&gt; testingFeatures &lt;- remainingFeatures[testingData,]</strong>
</pre><p><code class="literal"># plot()</code>功能是用于绘制R对象的通用功能。<code class="literal">stepValues</code>数据帧作为函数值传递:</p><pre class="programlisting">
<strong>    &gt; validationLabels &lt;- remainingLabels[-testingData]</strong>
<strong>    &gt; validationFeatures &lt;- remainingFeatures[-testingData,]</strong>
</pre><p>生成的图形如下所示:</p><pre class="programlisting">
<strong>&gt; getAccuracy &gt;- function(a,b,features,labels){
+ estFxn = features %*% a + b;
+ predictedLabels = rep(0,length(labels));
+ predictedLabels [estFxn &lt; 0] = -1 ;
+ predictedLabels [estFxn &gt;= 0] = 1 ;
+ return(sum(predictedLabels == labels) / length(labels))
+ }</strong>
</pre></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec115"/>Step 4 - building the model</h3></div></div></div><p>Setting up the initial parameters:</p><pre class="programlisting">
<strong>&gt; numEpochs = 100
&gt; numStepsPerEpoch = 500
&gt; nStepsPerPlot = 30
&gt; evalidationSetSize = 50
&gt; c1 = 0.01
&gt; c2 = 50</strong>
</pre><p>Combining a set of arguments. The result is stored in the <code class="literal">lambda_vals</code> data frame:</p><pre class="programlisting">
<strong>    &gt; lambda_vals = c(0.001, 0.01, 0.1, 1)     
&gt; bestAccuracy = 0</strong>
</pre><p>Exploring the internal structure of the <code class="literal">lambda_vals</code> data frame. The <code class="literal">str()</code> function displays the internal structure of the data frame. The <code class="literal">lambda_vals</code> is passed as an R object to the <code class="literal">str()</code> function:</p><pre class="programlisting">
<strong>    &gt; str(lambda_vals)</strong>
</pre><p>The result is as follows:</p><p>
</p><div><img src="img/image_06_142.jpg" alt="Step 4 - building the model"/></div><p>
</p><p>Creating a matrix for each epoch from a given set of values. The <code class="literal">matrix()</code> function is used. <code class="literal">nrow = (numStepsPerEpoch/nStepsPerPlot)*numEpochs+1</code> denotes the number of rows of the matrix, and <code class="literal">ncol = length(lambda_vals)</code> denotes the number of columns of the matrix:</p><pre class="programlisting">
<strong>    &gt; accMat &lt;- matrix(NA, nrow = (numStepsPerEpoch/nStepsPerPlot)*numEpochs+1, ncol = length(lambda_vals))</strong>
</pre><p>Creating a matrix for accuracy on a validation set from a given set of values. The <code class="literal">matrix()</code> function is used. <code class="literal">nrow = (numStepsPerEpoch/nStepsPerPlot)*numEpochs+1</code> denotes the number of rows of the matrix, and <code class="literal">ncol = length(lambda_vals)</code> denotes the number of columns of the matrix:</p><pre class="programlisting">
<strong>    &gt; accMatv &lt;- matrix(NA, nrow = (numStepsPerEpoch/nStepsPerPlot)*numEpochs+1, ncol = length(lambda_vals))</strong>
</pre><p>Setting up the classifier model:</p><pre class="programlisting">
<strong>    for(i in 1:4){ </strong>
<strong>      lambda = lambda_vals[i] </strong>
<strong>      accMatRow = 1 </strong>
<strong>      accMatCol = i </strong>
<strong>      a = rep(0,ncol(continuousFeatures)) </strong>
<strong>      b = 0 </strong>
<strong>      stepIndex = 0 </strong>
<strong>       for (e in 1:numEpochs){</strong>
</pre><p>The <code class="literal">#createDataPartition()</code> function creates a set of training data partitions. <code class="literal">y= trainingLabels</code> indicates the vector for outcomes. <code class="literal">p = (1 - evalidationSetSize/length(trainingLabels))</code> % of data is used for training datasets. The result is then stored in the <code class="literal">etrainingData</code> data frame:</p><pre class="programlisting">
<strong>etrainingData &lt;- createDataPartition(y=trainingLabels, p=(1 -   evalidationSetSize/length(trainingLabels)), list=FALSE) </strong>
<strong> etrainingFeatures &lt;- trainingFeatures[etrainingData,] </strong>
<strong> etrainingLabels &lt;- trainingLabels[etrainingData] </strong>
<strong> evalidationFeatures &lt;- trainingFeatures[-etrainingData,] </strong>
<strong> evalidationLabels &lt;- trainingLabels[-etrainingData] </strong>
<strong> steplength = 1 / (e*c1 + c2) </strong>
<strong>    for (step in 1:numStepsPerEpoch){ </strong>
<strong>      stepIndex = stepIndex+1 </strong>
<strong>      index = sample.int(nrow(etrainingFeatures),1) </strong>
<strong>      xk = etrainingFeatures[index,] </strong>
<strong>      yk = etrainingLabels[index] </strong>
<strong>       costfxn = yk * (a %*% xk + b) </strong>
<strong>       if(costfxn &gt;= 1){ </strong>
<strong>        a_dir = lambda * a </strong>
<strong>        a = a - steplength * a_dir </strong>
<strong>      } else { </strong>
<strong>        a_dir = (lambda * a) - (yk * xk) </strong>
<strong>        a = a - steplength * a_dir </strong>
<strong>        b_dir = -yk </strong>
<strong>        b = b - (steplength * b_dir) </strong>
<strong>      } </strong>
</pre><p>Logging in the accuracy. <code class="literal">getAccuracy()</code> is called:</p><pre class="programlisting">
<strong>    if (stepIndex %% nStepsPerPlot == 1){#30){ </strong>
<strong>    accMat[accMatRow,accMatCol] = getAccuracy(a,b,evalidationFeatures,evalidationLabels) </strong>
<strong>    accMatv[accMatRow,accMatCol] = getAccuracy(a,b,validationFeatures,validationLabels) </strong>
<strong>    accMatRow = accMatRow + 1 </strong>
<strong>    } </strong>
<strong>    } </strong>
<strong>    } </strong>
<strong>    tempAccuracy = getAccuracy(a,b,validationFeatures,validationLabels) </strong>
<strong>    print(str_c("tempAcc = ", tempAccuracy," and bestAcc = ", bestAccuracy) ) </strong>
<strong>    if(tempAccuracy &gt; bestAccuracy){ </strong>
<strong>    bestAccuracy = tempAccuracy </strong>
<strong>    best_a = a </strong>
<strong>    best_b = b </strong>
<strong>    best_lambdaIndex = i </strong>
<strong>    } </strong>
<strong>   }</strong>
</pre><p>Calculating the accuracy of the model. <code class="literal">getAccuracy()</code>, as defined previously, is used:</p><pre class="programlisting">
<strong>   &gt; getAccuracy(best_a,best_b, testingFeatures, testingLabels)</strong>
</pre></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec116"/>Step 5 - plotting the model</h3></div></div></div><p>Plotting the accuracy of the model during training. The <code class="literal">c()</code> function is used to combine the arguments into vectors:</p><pre class="programlisting">
<strong>    &gt; colors = c("red","blue","green","black")</strong>
</pre><p>Setting the vectors to be used in the graph:</p><pre class="programlisting">
<strong>&gt; xaxislabel = "Step"
&gt; yaxislabels = c("Accuracy on Randomized Epoch Validation
Set","Accuracy on Validation Set")
&gt;
&gt; ylims=c(0,1)
&gt; stepValues = seq(1,15000,length=500)</strong>
</pre><p>Creating a generic vector. <code class="literal">list()</code> is called, which concatenates the <code class="literal">accMat</code> and <code class="literal">accMatv</code> data frames:</p><pre class="programlisting">
<strong>    &gt; mats =  list(accMat,accMatv)</strong>
</pre><p>Plotting the graph:</p><pre class="programlisting">
<strong>&gt; for(j in 1:length(mats)){
mat = mats[[j]]
for(i in 1:4){
if(i == 1){</strong>
</pre><p>The <code class="literal"># plot()</code> function is a generic function for plotting R objects. The <code class="literal">stepValues</code> data frame is passed as a function value:</p><pre class="programlisting">
<strong>
    plot(stepValues, mat[1:500,i], type = "l",xlim=c(0, 15000), ylim=ylims,
</strong>
<strong>
         col=colors[i],xlab=xaxislabel,ylab=yaxislabels[j],main=title)
</strong>
<strong>
    } else{
</strong>
<strong>
      lines(stepValues, mat[1:500,i], type = "l",xlim=c(0, 15000), ylim=ylims,
</strong>
<strong>
          col=colors[i],xlab=xaxislabel,ylab=yaxislabels[j],main=title)
</strong>
<strong>
    }
</strong>
<strong>
   Sys.sleep(1)
</strong>
<strong>
  }
</strong>
<strong>
  legend(x=10000,y=.5,legend=c("lambda=.001","lambda=.01","lambda=.1","lambda=1"),fill=colors)
</strong>
<strong>
}
</strong>
</pre><p>The resulting graph will look like the following:</p><p>
</p><div><img src="img/image_06_143.jpg" alt="Step 5 - plotting the model"/></div><p>
</p></div></div></div>
</body></html>