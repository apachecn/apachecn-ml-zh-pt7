<html><head/><body>


    
        <title>Random Forest on iOS</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">iOS上的随机森林</h1>
                
            
            
                
<p>本章将为你提供随机森林算法的概述。我们将首先看看决策树算法，一旦我们掌握了它，试着理解随机森林算法。然后，我们将使用Core ML创建一个机器学习程序，该程序利用随机森林算法，并根据一组给定的乳腺癌患者数据预测患者被诊断为乳腺癌的可能性。</p>
<p>正如我们在<a href="51fcaf51-eb68-4493-afc2-0b02f1c1d50e.xhtml" target="_blank">第1章</a>、<em>移动机器学习简介、</em>中已经看到的，任何机器学习程序都有四个阶段:定义机器学习问题、准备数据、构建/重建/测试模型、部署使用。在本章中，我们将尝试将这些与随机森林联系起来，并解决底层的机器学习问题。</p>
<p><strong>问题定义</strong>:提供了某些患者的乳腺癌数据，我们想预测一个新数据项诊断乳腺癌的可能性。</p>
<p>我们将讨论以下主题:</p>
<ul>
<li>理解决策树以及如何应用它们解决ML问题</li>
<li>通过示例数据集和Excel了解决策树</li>
<li>了解随机森林</li>
<li>在核心ML中使用随机森林解决问题:<ul>
<li>技术要求</li>
<li>使用scikit-learn和pandas库创建模型文件</li>
<li>测试模型</li>
<li>将scikit-learn模型导入核心ML项目</li>
<li>编写一个iOS移动应用程序并使用其中的scikit-learn模型来执行乳腺癌预测</li>
</ul>
</li>
</ul>


            

            
        
    






    
        <title>Introduction to algorithms</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">算法简介</h1>
                
            
            
                
<p>在这一节中，我们将研究决策树算法。我们将通过一个例子来理解算法。一旦我们对算法有了一些了解，我们将通过一个例子来理解随机森林算法。</p>


            

            
        
    






    
        <title>Decision tree </title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">决策图表</h1>
                
            
            
                
<p>要理解随机森林模型，我们必须首先了解决策树，它是随机森林的基本构造块。我们在日常生活中都使用决策树，即使你不知道它的名字。一旦我们开始看这个例子，你将能够理解决策树的概念。</p>
<p>想象一下你向银行申请贷款。在批准贷款之前，银行会仔细检查你的一系列资格标准。对于每个人来说，他们提供的贷款金额会根据他们满足的不同资格标准而有所不同。</p>
<p>他们可能会继续进行各种决策点，以做出最终决定，从而确定是否可能发放贷款以及可以发放的贷款金额，例如:</p>
<ul>
<li><strong>收入来源</strong>:就业还是个体户？</li>
<li><strong>如果就业，就业地点</strong>:私营部门还是政府部门？</li>
<li><strong>如果是私营企业，薪资范围</strong>:低、中、高？</li>
<li><strong>如果是政府部门，工资范围</strong>:低、中、高？</li>
</ul>
<p>可能会有进一步的问题，比如你在那家公司工作了多长时间，或者你是否有未偿还的贷款。这个过程最基本的形式是一个决策树:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-923 image-border" src="img/8ed81da7-31ba-4376-b2ef-ca932251b95e.png" style="width:33.42em;height:25.25em;"/></p>
<p>正如您在前面的图表中所看到的，决策树是一种广泛用于分类问题的非参数有效机器学习建模技术。为了找到解决方案，决策树根据预测数据对结果做出连续的分层决策。</p>
<p>对于任何给定的数据项，会询问一系列问题，这些问题会导致一个类标签或一个值。该模型询问传入数据项的一系列预定义问题，并基于这些答案，分支到该系列并继续进行，直到到达结果数据值或类标签。该模型是基于观察到的数据构建的，并且没有关于误差分布或数据本身分布的假设。</p>
<p>在目标变量使用一组离散值的决策树模型中，这被称为<strong>分类树</strong>。在这些树中，每个节点或叶子代表类别标签，而分支代表通向类别标签的特征。</p>
<p>目标变量取连续值(通常是数字)的决策树被称为<strong>回归树</strong>。</p>
<p>使用<strong>有向无环图</strong> ( <strong> DAGs </strong>)可以很好地表示这些决策树。在这些图中，节点代表决策点，边是节点之间的连接。在前面的贷款场景中，30，000美元到70，000美元的工资范围是优势，中间是节点。</p>


            

            
        
    






    
        <title>Advantages of the decision tree algorithm</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">决策树算法的优势</h1>
                
            
            
                
<p>决策树的目标是对给定的问题做出最佳选择。最后的叶节点应该是手头问题的最佳选择。该算法贪婪地运行，并试图在其做出的每个决策中找到最佳选择。</p>
<p>整个问题被分成多个子问题，每个子问题又分支到其他子问题。到达的子集基于名为<strong>纯度</strong>的参数。当所有的决定将导致属于同一类的数据时，称一个节点是100%纯的。当有可能将其子集分成类别时，它将是100%不纯的。该算法的目标是使树中的每个节点达到100%的纯度。</p>
<p>节点的纯度使用基尼系数来衡量，基尼系数是一个标准的度量标准，有助于分裂决策树的节点。</p>
<p>决策树中使用的另一个度量是信息增益，它将用于决定在树中的每一步应该使用数据集的什么特征进行分割。信息增益是在属性上分割数据集后熵(随机性)的减少。构建决策树就是要找到返回最高信息增益的属性，也就是最同质的分支，这意味着所有数据都属于同一个子集或类。</p>


            

            
        
    






    
        <title>Disadvantages of decision trees</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">决策树的缺点</h1>
                
            
            
                
<p>只有当所有数据点都可以归入一个类/类别时，模型才会停止。因此，对于复杂的问题，它可能不能很好地推广，出现偏差的可能性很大。</p>
<p>这些问题可以通过定义树的最大深度或指定在树中进一步分割节点所需的最小数据点数来解决。</p>


            

            
        
    






    
        <title>Advantages of decision trees</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">决策树的优势</h1>
                
            
            
                
<p>下面列出了一些优点:</p>
<ul>
<li>易于理解和可视化</li>
<li>非常容易构建，可以处理定性和定量数据</li>
<li>易于验证</li>
<li>从计算上来说，这并不昂贵</li>
</ul>
<p>总结一下决策树模型，我们可以得出这样的结论:它基本上是一个问题的流程图，这些问题导致一个预测。</p>


            

            
        
    






    
        <title>Random forests</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">随机森林</h1>
                
            
            
                
<p>现在，让我们从单个决策树转移到随机森林。如果你想猜测下一任总统会是谁，你会如何预测？让我们看看我们会问哪些不同类型的问题来预测这一点:</p>
<ul>
<li>有多少候选人？他们是谁？</li>
<li>现任总统是谁？</li>
<li>他们表现如何？</li>
<li>他们属于哪个政党？</li>
<li>目前有反对该党运动吗？</li>
<li>这个政党有可能在多少个州获胜</li>
<li>他们是现任总统吗？</li>
<li>主要的投票议题是什么？</li>
</ul>
<p>许多类似这样的问题会浮现在我们的脑海中，我们会赋予它们不同的权重/重要性。</p>
<p class="mce-root">每个人对前面问题的预测可能不一样。要考虑的因素太多了，而且每个人的猜测可能都不一样。每个人都有不同的背景和知识水平来回答这些问题，并且可能对问题有不同的解释。</p>
<p class="mce-root">所以答案有可能有很大的差异。如果我们把不同个体给出的所有预测分别拿出来，然后平均一下，就变成了随机森林。</p>
<p>随机森林将许多决策树组合成一个模型。单独来看，决策树(或人类)做出的预测可能不准确，但是当组合起来时，平均来说，预测会更接近目标。</p>
<p>下图将帮助我们理解使用随机森林算法的投票预测:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-925 image-border" src="img/5bf737ee-2d42-4d41-b7ce-7ebeb1966472.png" style="width:40.25em;height:22.17em;"/></p>
<p>下图给出了上图的流程图视图:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-924 image-border" src="img/531ae8f1-7db7-4759-b594-4fc3ce0d9a31.png" style="width:15.50em;height:20.92em;"/></p>
<p>让我们看看为什么随机森林比决策树更好:</p>
<ul>
<li>随机森林是许多决策树的组合，因此，很有可能会有许多观点来达成最终预测。</li>
<li>如果只考虑单个决策树进行预测，则考虑用于预测的信息较少。但是，在一个随机的森林中，当涉及到许多树木时，就有更多的信息，而且更加多样化。</li>
<li>与决策树的情况不同，随机森林可能没有偏向，因为它不依赖于单个源。</li>
</ul>
<p class="mce-root">为什么叫随机森林？尽管人们可能依赖不同的来源来做出预测，但森林中的每个决策树在形成问题时都会考虑随机的特征子集，并且只能访问随机的一组训练数据点。这增加了森林中的多样性，导致更稳健的整体预测，因此命名为随机森林。</p>


            

            
        
    






    
        <title>Solving the problem using random forest in Core ML</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">在核心ML中使用随机森林解决问题</h1>
                
            
            
                
<p>在本节中，我们将通过一个带有特定数据集的详细示例来尝试理解随机森林。我们将使用相同的数据集来计算iOS核心ML示例。</p>


            

            
        
    






    
        <title>Dataset</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">资料组</h1>
                
            
            
                
<p>我们将使用乳腺癌数据集来解决随机森林问题。从乳腺肿块的<strong>细针抽吸</strong> ( <strong> FNA </strong>)的数字化图像中计算特征。它们描述了图像中出现的细胞核的特征。数据集可以在<a href="https://archive.ics.uci.edu/ml/datasets/Breast+Cancer+Wisconsin+(Diagnostic)">https://archive . ics . UCI . edu/ml/datasets/Breast+Cancer+Wisconsin+(Diagnostic)</a>找到。</p>


            

            
        
    






    
        <title>Naming the dataset</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">命名数据集</h1>
                
            
            
                
<p>我们将使用乳腺癌数据集。以下列表包含数据集中使用的各种约定:</p>
<ul>
<li>识别号</li>
<li>诊断(<em> M </em> =恶性，而<em> B </em> =良性)</li>
</ul>
<ul>
<li>为每个细胞核计算10个实值特征:<ul>
<li>半径(从中心到周边各点的平均距离)</li>
<li>纹理(灰度值的标准偏差)</li>
<li>周长</li>
<li>面积</li>
<li>平滑度(半径长度的局部变化)</li>
<li>紧凑性(<em> perimeter^2/area - 1.0 </em>)</li>
<li>凹度(轮廓凹陷部分的严重程度)</li>
<li>凹点(轮廓凹陷部分的数量)</li>
<li>对称</li>
<li>分形维数(海岸线近似值-1)</li>
</ul>
</li>
</ul>
<p>我们将通过Excel使用随机森林，应用乳腺癌数据集，详细了解随机森林。出于分析的目的，我们将只考虑来自乳腺癌数据集的569个样本数据的数据元素。</p>


            

            
        
    






    
        <title>Technical requirements</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">技术要求</h1>
                
            
            
                
<p>开发人员计算机上需要安装以下软件:</p>
<ul>
<li>计算机编程语言</li>
<li>macOS环境中的Xcode</li>
</ul>
<p>本章的练习程序可以在GitHub资源库(<a href="https://github.com/PacktPublishing/Machine-Learning-for-Mobile">https://GitHub . com/packt publishing/Machine-Learning-for-Mobile</a>)的<kbd>Chapter03</kbd>文件夹下找到。让我们从输入安装Python包的命令开始:</p>
<pre>pip install pandas<br/>pip install -U scikit-learn<br/>pip install -U pandas</pre>
<p>然后，发出安装<kbd>coremltools</kbd>的命令:</p>
<pre>pip install -U coremltools</pre>


            

            
        
    






    
        <title>Creating the model file using scikit-learn </title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">使用scikit-learn创建模型文件</h1>
                
            
            
                
<p>本节将解释我们如何使用scikit-learn创建随机森林模型文件，并将其转换成与Core ML兼容的<kbd>.mlmodel</kbd>文件。我们将使用乳腺癌数据集来创建模型。以下是使用scikit-learn和乳腺癌数据集创建简单随机森林模型的Python程序。然后，核心ML工具将它转换成核心ML兼容的模型文件。让我们详细地看一下这个程序。</p>
<p>首先，我们需要导入所需的包:</p>
<pre># importing required packages<br/> import numpy as np</pre>
<p>NumPy是使用Python进行科学计算的基础包。它包含了一个强大的N维数组对象。这个<kbd>numpy</kbd>数组将在这个程序中用于存储数据集，它有14个维度:</p>
<pre>import pandas as pd<br/> from pandas.core import series</pre>
<p>这里，我们使用pandas(<a href="https://pandas.pydata.org/pandas-docs/stable/10min.html">https://pandas.pydata.org/pandas-docs/stable/10min.html</a>)，它是一个开源的、BSD许可的库，为Python编程语言提供了高性能、易于使用的数据结构和数据分析工具。使用熊猫，我们可以创建一个数据框。你可以假设熊猫数据框架是一个Excel表格，其中每个表格都有标题和数据。</p>
<p>现在，让我们继续理解为解决手头的机器学习问题而编写的程序:</p>
<pre>from sklearn.ensemble import RandomForestClassifier<br/><br/>from sklearn.metrics import accuracy_score<br/>import sklearn.datasets as dsimport sklearn.datasets as ds</pre>
<p>前面几行导入了<kbd>sklearn</kbd>包。现在，我们将导入<kbd>sklearn</kbd>包中的内置数据集:</p>
<pre>dataset = ds.load_breast_cancer()</pre>
<p>前面一行从<kbd>sklearn</kbd>数据集包中加载乳腺癌数据集:</p>
<pre> cancerdata = pd.DataFrame(dataset.data)</pre>
<p>这将从数据集中的数据创建一个数据帧。让我们假设数据集是一个Excel表，包含带有列标题的行和列:</p>
<pre> cancerdata.columns = dataset.feature_names</pre>
<p>下面这段代码将向数据集中的列添加列标题:</p>
<pre>for i in range(0,len(dataset.feature_names)):<br/>if ['mean concave points', 'mean area', 'mean radius', 'mean perimeter', 'mean concavity'].\<br/>__contains__(dataset.feature_names[i]):<br/>continue<br/>else:<br/>cancerdata = cancerdata.drop(dataset.feature_names[i], axis=1)</pre>
<p>前面的行将删除除下列以外的所有列:</p>
<ul>
<li>平均凹点</li>
<li>平均面积</li>
<li>平均半径</li>
<li>平均周长</li>
<li>平均凹度</li>
</ul>
<p class="mce-root">为了减少数据集中要素列的数量，我删除了一些对模型影响较小的列:</p>
<pre>cancerdata.to_csv("myfile.csv")</pre>
<p>这一行将数据保存到一个CSV文件中；您可以打开它并在Excel中查看，找出数据集中存在的内容:</p>
<pre> cancer_types = dataset.target_names</pre>
<p>在Excel数据集中，当您检查它时，您会知道诊断将包括值0或1，其中0是恶性的，1是良性的。为了将这些数值改为真实的名称，我们编写了以下代码:</p>
<pre>cancer_names = []<br/>//getting all the corresponding cancer types with name [string] format.<br/>for i in range(len(dataset.target)):<br/>cancer_names.append(cancer_types[dataset.target[i]])<br/>x_train, x_test, y_train, y_test = sklearn.model_selection.train_test_split(cancerdata,cancer_names,test_size=0.3, random_state=5)</pre>
<p>这一行代码将数据集一分为二，一个用于训练，一个用于测试，并将它保存在为此目的定义的相应变量中:</p>
<pre> classifier = RandomForestClassifier()</pre>
<p>下面将创建一个分类器:</p>
<pre>classifier.fit(x_train, y_train)</pre>
<p>此代码将提供训练数据并训练模型:</p>
<pre>//testing the model with test data<br/>print(classifier.predict(x_test))</pre>
<p>前面一行将把测试数据的预测癌症类型打印到控制台，如下所示:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/db7a7788-e16b-434d-8d39-2c5c91e3eddc.png" style="width:57.58em;height:33.58em;"/></p>


            

            
        
    






    
        <title>Converting the scikit model to the Core ML model</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">将scikit模型转换为核心ML模型</h1>
                
            
            
                
<p>让我用一个例子来解释:假设你来自法国，你只会说法语和英语。想象你去印度度假。你去旅馆的餐厅，服务员给你一份用当地语言写的菜单。现在，你会怎么做？让我猜猜，你会要求服务员，或者另一个顾客/你的导游，向你解释这些项目，或者你只是在谷歌翻译中扫描图片。</p>
<p>我的观点是你需要一个翻译。就是这样。类似地，为了让iOS移动应用程序理解scikit模型，需要一个将它转换为核心ML格式的转换器。</p>
<p>这就是下面代码的全部工作。它会将scikit-learn格式转换为核心ML格式:</p>
<pre>//converting the fitted model to a Core ML Model file<br/><br/>model = coremltools.converters.sklearn.convert(classifier, input_features=list(cancerdata.columns.values), output_feature_names='typeofcancer')<br/><br/>model.save("cancermodel.mlmodel")</pre>
<p>为此，要工作，你必须使用你的<kbd>pip</kbd>安装<kbd>coremltools</kbd>。然后，在顶部编写以下代码来导入它:</p>
<pre>import coremltools</pre>
<p>一旦你运行这个程序，你会在你的磁盘上得到一个模型文件，名为<kbd>cancermodel.mlmodel</kbd>，你将在你的iOS项目中使用它进行推理。</p>


            

            
        
    






    
        <title>Creating an iOS mobile application using the Core ML model</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">使用核心ML模型创建iOS移动应用程序</h1>
                
            
            
                
<p>在本节中，我们将创建一个iOS项目来使用Core ML，为此您将需要Xcode(它必须是版本9+)。</p>
<p>让我们从打开Xcode并创建一个带有故事板的空swift应用程序开始。在主要的故事板设计中，屏幕将如下所示。然后，将生成的模型文件添加到您的项目中。这将为您提供以下结构:</p>
<p class="mce-root"/>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-928 image-border" src="img/8852eb62-93c8-45a7-b04b-118ab566e3f1.png" style="width:14.83em;height:18.58em;"/></p>
<p>现在，在主故事板文件中创建UI，如下所示:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/caaef230-54a1-4912-bd7e-9679cae60ff4.png" style="width:17.83em;height:32.00em;"/></p>
<p>为每个文本字段创建出口。并将事件侦听器添加到每个文本字段中。现在，您的视图控制器将如下所示:</p>
<pre>import UIKit<br/>import Core ML <br/>class ViewController: UIViewController {<br/>    let model = cancermodel()<br/>    @IBOutlet weak var meanradius: UITextField!<br/>    @IBOutlet weak var cancertype: UILabel!<br/>    @IBOutlet weak var meanperimeter: UITextField!<br/>    @IBOutlet weak var meanarea: UITextField!<br/>    @IBOutlet weak var meanconcavity: UITextField!<br/>    @IBOutlet weak var meanconcavepoints: UITextField!<br/>    override func didReceiveMemoryWarning() {<br/>        super.didReceiveMemoryWarning()<br/>        // Dispose of any resources that can be recreated.<br/>    }<br/>    override func viewDidLoad() {<br/>        super.viewDidLoad();<br/>        updated(meanconcavepoints);<br/>        //This line is to fire the initial update of the cancer type.<br/>    }<br/>    /*<br/>This method will send the input data to your generated model class and display the returned result to the label.<br/>*/<br/><br/>    @IBAction func updated(_ sender: Any) {<br/>        guard let modeloutput = try? model.prediction(mean_radius: <br/>        Double(meanradius.text!)!, mean_perimeter: <br/>        Double(meanperimeter.text!)!, mean_area: Double(meanarea.text!)!, <br/>        mean_concavity: Double(meanconcavity.text!)!, mean_concave_points: <br/>        Double(meanconcavepoints.text!)!) else {<br/>            fatalError("unexpected runtime error")<br/>        }<br/>        cancertype.text = modeloutput.typeofcancer;<br/>    }<br/>}</pre>
<p>您可以在本书的GitHub资源库中找到相同的代码。</p>
<p>如果您在构建过程中遇到任何问题。如签名或证书，请谷歌它或写信给我们。</p>
<p>一旦在Xcode中设置了项目，就可以在模拟器中运行它。结果将如下所示:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/5a912732-bce4-4f4c-b19f-b715bbfa735f.png" style="width:19.42em;height:34.58em;"/></p>


            

            
        
    






    
        <title>Summary</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">摘要</h1>
                
            
            
                
<p>在这一章中，我们学习了决策树和随机森林，以及它们之间的区别。我们还通过样本数据集和使用样本数据集的Excel来探索决策树，并对其使用随机森林算法以建立预测。我们使用Core ML编写iOS程序，然后应用scikit-learn创建模型，并使用Core ML工具将scikit模型转换为Core ML模型。</p>
<p>在下一章中，我们将了解更多关于TensorFlow及其在Android中的使用。</p>


            

            
        
    






    
        <title>Further reading</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">进一步阅读</h1>
                
            
            
                
<p>通过访问Core ML的官方网站:<a href="https://developer.apple.com/documentation/coreml">https://developer.apple.com/documentation/coreml</a>，我们可以进一步了解Core ML及其提供的服务。</p>


            

            
        
    


</body></html>